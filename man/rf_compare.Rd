% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rf_compare.R
\name{rf_compare}
\alias{rf_compare}
\title{Compares models via spatial cross-validation}
\usage{
rf_compare(
  models = NULL,
  xy = NULL,
  repetitions = 30,
  training.fraction = 0.75,
  distance.step = NULL,
  fill.color = viridis::viridis(100, option = "F", direction = -1, alpha = 0.8),
  line.color = "gray30",
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
}
\arguments{
\item{models}{Named list with models resulting from \code{\link[=rf]{rf()}}, \code{\link[=rf_spatial]{rf_spatial()}}, \code{\link[=rf_tuning]{rf_tuning()}}, or \code{\link[=rf_evaluate]{rf_evaluate()}}. Example: \code{models = list(a = model.a, b = model.b)}. Default: \code{NULL}}

\item{xy}{Data frame or matrix with two columns containing coordinates and named "x" and "y". Default: \code{NULL}}

\item{repetitions}{Integer, number of spatial folds to use during cross-validation. Must be lower than the total number of rows available in the model's data. Default: \code{30}}

\item{training.fraction}{Proportion between 0.5 and 0.9 indicating the proportion of records to be used as training set during spatial cross-validation. Default: \code{0.75}}

\item{distance.step}{(optional; numeric) Numeric vector of length one or two. Distance step used during the growth of the buffer containing the training cases. Must be in the same units as the coordinates in \code{xy}. When only one distance is provided, the same growth is applied to the x and y axes. If two distances are provided, the first one is applied to the x axis, and the second one to the y. When \code{NULL}, it uses 1/1000th of the range of each axis as distance. The smaller this number is, the easier is to achieve an accurate \code{training.fraction}, but the slower the algorithm becomes. Default: \code{NULL}}

\item{fill.color}{Character vector with hexadecimal codes (e.g. "#440154FF" "#21908CFF" "#FDE725FF"), or function generating a palette (e.g. \code{viridis::viridis(100)}). Default: \code{viridis::viridis(100, option = "F", direction = -1)}}

\item{line.color}{Character string, color of the line produced by \code{ggplot2::geom_smooth()}. Default: \code{"gray30"}}

\item{seed}{Integer, random seed to facilitate reproduciblity. If set to a given number, the results of the function are always the same. Default: \code{1}.}

\item{verbose}{Logical. If \code{TRUE}, messages and plots generated during the execution of the function are displayed, Default: \code{TRUE}}

\item{n.cores}{Integer, number of cores used by \code{\link[ranger]{ranger}} for parallel execution (used as value for the argument \code{num.threads} in \code{ranger()}). Default: \code{NULL}}

\item{cluster}{A cluster definition generated with \code{parallel::makeCluster()} or \code{\link{start_cluster}}. Only advisable if you need to spread a large number of repetitions over the nodes of a large cluster. If provided, overrides \code{n.cores}. The function does not stop a cluster, please remember to shut it down with \code{parallel::stopCluster(cl = cluster_name)} at the end of your pipeline. Default: \code{parallel::detectCores() - 1}}
}
\value{
A list with three slots:
\itemize{
\item \code{comparison.df}: Data frame with one performance value per spatial fold, metric, and model.
\item \code{spatial.folds}: List with the indices of the training and testing records for each evaluation repetition.
\item \code{plot}: Violin-plot of \code{comparison.df}.
}
}
\description{
Uses \code{\link[=rf_evaluate]{rf_evaluate()}} to compare the performance of several models on independent spatial folds via spatial cross-validation.
}
\examples{
if(interactive()){

 #loading example data
data(
  ecoregions_df,
  ecoregions_distance_matrix,
  ecoregions_numeric_predictors,
  ecoregions_continuous_response
  )

 #fitting random forest model
 rf.model <- rf(
   data = ecoregions_df,
   response.name = ecoregions_continuous_response,
   predictors.names = ecoregions_numeric_predictors,
   distance.matrix = ecoregions_distance_matrix,
   distance.thresholds = 0,
   n.cores = 1
 )

 #fitting a spatial model with Moran's Eigenvector Maps
 rf.spatial <- rf_spatial(
 model = rf.model,
 n.cores = 1
 )

 #comparing the spatial and non spatial models
 comparison <- rf_compare(
 models = list(
   `Non spatial` = rf.model,
   Spatial = rf.spatial
 ),
 xy = ecoregions_df[, c("x", "y")],
 n.cores = 1
 )

}
}
\seealso{
\code{\link[=rf_evaluate]{rf_evaluate()}}
}
