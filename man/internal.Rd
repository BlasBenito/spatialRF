% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fe_target_encoding_methods.R, R/internal.R
\name{fe_target_encoding_noise}
\alias{fe_target_encoding_noise}
\alias{case_weights}
\alias{non_numeric_columns}
\alias{numeric_columns}
\alias{check_distance_thresholds}
\alias{check_distance_matrix}
\alias{check_data}
\alias{check_predictors_names}
\alias{check_response_name}
\alias{optimization_function}
\alias{filter_spatial_predictors}
\alias{default_distance_thresholds}
\alias{is_binary_response}
\alias{prepare_importance_spatial}
\title{Generates case weights for binary responses}
\usage{
fe_target_encoding_noise(data, categorical.variable.name, noise = 0, seed = 1)

case_weights(x = NULL, case.weights = NULL)

non_numeric_columns(data, columns = NULL)

numeric_columns(data = NULL, columns = NULL)

check_distance_thresholds(
  distance.thresholds = NULL,
  distance.matrix = NULL,
  is.required = TRUE,
  verbose = TRUE
)

check_distance_matrix(
  data = NULL,
  distance.matrix = NULL,
  is.required = TRUE,
  verbose = TRUE
)

check_data(data = NULL, na.allowed = TRUE, verbose = TRUE)

check_predictors_names(
  predictors.names = NULL,
  data = NULL,
  numeric.only = TRUE,
  is.required = TRUE,
  verbose = TRUE
)

check_response_name(
  response.name = NULL,
  data = NULL,
  is.required = TRUE,
  verbose = TRUE
)

optimization_function(
  x = NULL,
  weight.performance = NULL,
  weight.penalization.n.predictors = NULL,
  optimization.method = "moran.i"
)

filter_spatial_predictors(
  data = NULL,
  predictors.names = NULL,
  response.name = NULL,
  spatial.predictors.df = NULL,
  max.cor = 0.5
)

default_distance_thresholds(distance.matrix = NULL)

is_binary_response(x)

prepare_importance_spatial(model)
}
\arguments{
\item{data}{(required, data frame) Data frame with a response variable and a set of predictors. Default: \code{NULL}}

\item{x}{Optimization data frame generated internally by \code{\link[=select_spatial_predictors_sequential]{select_spatial_predictors_sequential()}} or \code{\link[=select_spatial_predictors_recursive]{select_spatial_predictors_recursive()}}. Default: \code{NULL}}

\item{case.weights}{(optional, numeric vector) Numeric vector with case weights. Only for internal use within the package. Default: \code{NULL}}

\item{columns}{A character vector specifying the columns of the data frame to extract.}

\item{distance.thresholds}{main argument.}

\item{distance.matrix}{Distance matrix. Default: \code{NULL}.}

\item{is.required}{logical}

\item{verbose}{logical}

\item{na.allowed}{logical, changes the check depending on whether NAs are allowed in data or not.}

\item{predictors.names}{(required, character vector) Character vector with the names of the predictive variables. Every element of this vector must be in the column names of \code{data}. Default: \code{NULL}}

\item{numeric.only}{logical}

\item{response.name}{(optional; character string) Name of the dependent variable. Only required when there are categorical variables within \code{predictors.names}. Default: \code{NULL}}

\item{weight.performance}{Numeric between 0 and 1, weight of R-squared in the optimization process. Default: \code{NULL}}

\item{weight.penalization.n.predictors}{Numeric between 0 and 1, weight of the penalization on the number of added spatial predictors. Default: \code{NULL}}

\item{optimization.method}{Character, one of "moran.i", and "p.value". Default: \code{"moran.i"}}

\item{spatial.predictors.df}{(required, data frame) Data frame of spatial predictors.}

\item{max.cor}{(optional, numeric) Numeric between 0 and 1, maximum Pearson correlation between any pair of the selected variables. Default: \code{0.50}}

\item{model}{An importance data frame with spatial predictors, or a model fitted with \code{\link[=rf_spatial]{rf_spatial()}}.}
}
\value{
A vector with a length equal to \code{x} with case weights.

A character vector with the names of the numeric columns in the selected data frame.

A character vector with the names of the non-numeric columns in the selected data frame.

distance thresholds

distance matrix

data

predictor.names

response.name

A numeric vector with the optimization criteria.

A data frame with non-redundant spatial predictors.

A numeric vector with distance thresholds.

A list with importance data frames in different formats depending on whether the model was fitted with \code{\link[=rf]{rf()}} or \code{\link[=rf_repeat]{rf_repeat()}}.
}
\description{
When the data is binary, setting the \code{ranager} argument \code{case.weights} helps to minimize the issues produced by class imbalance. This function takes a binary response variable and returns a vector of weights populated with the values \verb{1/#zeros} and \verb{1/#ones}. It is used internally by the function \code{\link[=rf]{rf()}}.

This function takes a data frame and a set of columns and returns the names of the numeric columns in the selected data frame.

This function takes a data frame and a set of columns and returns the names of the non-numeric columns in the selected data frame.

Optimizes the selection of spatial predictors using two different methods: "moran.i", and "p.value".

Removes spatial predictors that are pair-wise correlated with other spatial predictors (which happens when there are several close distance thresholds), and spatial predictors correlated with non-spatial predictors.

Generates four distance thresholds, from 0 to max(distance.matrix)/2.

Prepares variable importance data frames and plots for models fitted with \code{\link[=rf_spatial]{rf_spatial()}}.
}
\details{
The method "moran.i" tries to maximize \verb{1 - Moran's} I while taking into account the R-squared of the model and a penalization on the number of introduced spatial predictors through the expression

(1 - Moran's I) + w1 * rsquared - w2 * penalization

The method "p.value" uses a binary version of the p-values of Moran's I (1 if >= 0.05, 0 otherwise), and uses the expression

max(1 - Moran's I, binary p-value) + w1 * rsquared - w2 * penalization

The "moran.i" method generally selects more spatial predictors than the "p.value" method.
}
\examples{
if(interactive()){

 case_weights(
   x = c(0, 0, 0, 1, 1)
 )

 }
if(interactive()){

data(
  ecoregions_df,
  ecoregions_distance_matrix,
  ecoregions_numeric_predictors,
  ecoregions_continuous_response
  )

#computing Moran's Eigenvector Maps
spatial.predictors.df <- mem_multithreshold(
  distance.matrix = ecoregions_distance_matrix,
  distance.thresholds = c(0, 1000)
  )

#filtering spatial predictors
spatial.predictors.df <- filter_spatial_predictors(
  data = ecoregions_df,
  predictors.names = ecoregions_numeric_predictors,
  spatial.predictors.df = spatial.predictors.df,
  max.cor = 0.50
 )

 spatial.predictors.df


}
if(interactive()){

 #loading example distance matrix
 data(ecoregions_distance_matrix)

 #computing set of default distance thresholds
 default_distance_thresholds(ecoregions_distance_matrix)

 }
if(interactive()){

#loading example data
data(
  ecoregions_df,
  ecoregions_distance_matrix,
  ecoregions_numeric_predictors,
  ecoregions_continuous_response
  )

 #fittind spatial model
 model <- rf_spatial(
   data = ecoregions_df,
   response.name = ecoregions_continuous_response,
   predictors.names = ecoregions_numeric_predictors,
   distance.matrix = ecoregions_distance_matrix,
   distance.thresholds =  0,
   n.cores = 1
 )

 #preparing the importance data frame
 importance <- prepare_importance_spatial(model)
 names(importance)

}
}
\seealso{
\code{\link[=select_spatial_predictors_recursive]{select_spatial_predictors_recursive()}}, \code{\link[=select_spatial_predictors_sequential]{select_spatial_predictors_sequential()}}
}
\keyword{internal}
