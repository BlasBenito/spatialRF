#' @title Ranks spatial predictors
#' @description Ranks spatial predictors generated by [mem_multithreshold()] or [pca_multithreshold()] by their effect in reducing the Moran's I of the model residuals (`ranking.method = "effect"`), or by their own Moran's I (`ranking.method = "moran"`).
#'
#' In the former case, one model of the type `y ~ predictors + spatial_predictor_X` is fitted per spatial predictor, and the Moran's I of the model residuals residuals is compared with the one of the model without spatial predictors (`y ~ predictors`), to finally rank the spatial predictor from maximum to minimum difference in Moran's I.
#'
#' In the latter case, the spatial predictors are ordered by their Moran's I alone (this is the faster option).
#'
#' In both cases, spatial predictors with no effect (no reduction of Moran's I  or Moran's I of the spatial predictor equal or lower than 0) are removed.
#'
#' This function has been designed to be used internally by [rf_spatial()] rather than directly by a user.
#' @param data Data frame with a response variable and a set of predictors. Default: `NULL`
#' @param dependent.variable.name Character string with the name of the response variable. Must be in the column names of `data`. Default: `NULL`
#' @param predictor.variable.names Character vector with the names of the predictive variables. Every element of this vector must be in the column names of `data`. Default: `NULL`
#' @param reference.moran.i Moran's I of the residuals of the model without spatial predictors. Default: `1`
#' @param distance.matrix Squared matrix with the distances among the records in `data`. The number of rows of `distance.matrix` and `data` must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: `NULL`
#' @param distance.thresholds Numeric vector with neighborhood distances. All distances in the distance matrix below each value in `dustance.thresholds` are set to 0 for the computation of Moran's I. If `NULL`, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: `NULL`
#' @param ranger.arguments List with \link[ranger]{ranger} arguments. See [rf] or [rf_repeat] for further details.
#' @param spatial.predictors.df Data frame of spatial predictors.
#' @param ranking.method Character, method used by to rank spatial predictors. The method "effect" ranks spatial predictors according how much each predictor reduces Moran's I of the model residuals, while the method "moran" ranks them by their own Moran's I.
#' @param n.cores Integer, number of cores to use during computations. If `NULL`, all cores but one are used, unless a cluster is used. Default = `NULL`
#' @param cluster.ips Character vector with the IPs of the machines in a cluster. The machine with the first IP will be considered the main node of the cluster, and will generally be the machine on which the R code is being executed.
#' @param cluster.cores Numeric integer vector, number of cores to use on each machine.
#' @param cluster.user Character string, name of the user (should be the same throughout machines). Defaults to the current system user.
#' @param cluster.port Integer, port used by the machines in the cluster to communicate. The firewall in all computers must allow traffic from and to such port. Default: `11000`
#' @return A list with three slots:
#' \itemize{
#' \item `method`: Character, name of the method used to rank the spatial predictors.
#'  \item `criteria`: Data frame with two different configurations depending on the ranking method. If `ranking.method = "effect"`, the columns contain the names of the spatial predictors, the r-squared of the model, the Moran's I of the model residuals, the difference between the Moran's I of the model including the given spatial predictor, and the Moran's I of the model fitted without spatial predictors, and the interpretation of the Moran's I value. If `ranking.method = "moran"`, only the name of the spatial predictor and it's Moran's I are in the output data frame.
#'  \item `ranking`: Ordered character vector with the names of the spatial predictors selected.
#' }
#' @examples
#' \donttest{
#' if(interactive()){
#'  data("distance_matrix")
#'
#'  spatial.predictors.df <- pca_distance_matrix(
#'    x = distance_matrix[1:50, 1:50],
#'    distance.thresholds = c(0, 100, 1000)
#'  )
#'
#'  #ranking by the Moran's I of the spatial predictor
#'  rank <- rank_spatial_predictors(
#'    distance.matrix = distance_matrix[1:50, 1:50],
#'    distance.thresholds = c(0, 100, 1000),
#'    spatial.predictors.df = spatial.predictors.df,
#'    ranking.method = "effect",
#'    n.cores = 1
#'  )
#'  rank$ranking.criteria
#'  rank$ranking
#'  }
#' }
#' @rdname rank_spatial_predictors
#' @export
rank_spatial_predictors <- function(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  ranking.method = c("effect", "moran"),
  reference.moran.i = 1,
  n.cores = NULL,
  cluster.ips = NULL,
  cluster.cores = NULL,
  cluster.user = Sys.info()[["user"]],
  cluster.port = 11000
){

  #testing method argument
  ranking.method <- match.arg(
    arg = ranking.method,
    choices = c("effect", "moran"),
    several.ok = FALSE
    )

  #add write.forest = FALSE to ranger.arguments
  if(is.null(ranger.arguments)){
    ranger.arguments <- list()
  }
  ranger.arguments$write.forest <- FALSE
  ranger.arguments$importance <- "none"
  ranger.arguments$local.importance <- FALSE
  ranger.arguments$keep.inbag <- FALSE
  ranger.arguments$write.forest <- FALSE
  ranger.arguments$num.trees <- 500

  #reference.moran.i
  if(is.null(reference.moran.i)){reference.moran.i <- 1}

  #setup of parallel execution
  if(is.null(n.cores)){

    n.cores <- parallel::detectCores() - 1
    `%dopar%` <- foreach::`%dopar%`

  } else {

    #only one core, no cluster
    if(n.cores == 1){

      #replaces dopar (parallel) by do (serial)
      `%dopar%` <- foreach::`%do%`
      on.exit(`%dopar%` <- foreach::`%dopar%`)

    } else {

      `%dopar%` <- foreach::`%dopar%`

    }

  }

  #local cluster
  if(is.null(cluster.ips) & n.cores > 1){

    if(.Platform$OS.type == "windows"){
      temp.cluster <- parallel::makeCluster(
        n.cores,
        type = "PSOCK"
      )
    } else {
      temp.cluster <- parallel::makeCluster(
        n.cores,
        type = "FORK"
      )
    }

    #register cluster and close on exit
    doParallel::registerDoParallel(cl = temp.cluster)
    on.exit(parallel::stopCluster(cl = temp.cluster))

  }

  #beowulf cluster
  if(!is.null(cluster.ips)){


    #cluster port
    Sys.setenv(R_PARALLEL_PORT = cluster.port)

    #preparing the cluster specification
    cluster.spec <- cluster_specification(
      cluster.ips = cluster.ips,
      cluster.cores = cluster.cores,
      cluster.user = cluster.user
    )

    #cluster setup
    temp.cluster <- parallel::makeCluster(
      master = cluster.ips[1],
      spec = cluster.spec,
      port = cluster.port,
      outfile = "",
      homogeneous = TRUE
    )

    #register cluster and close on exit
    doParallel::registerDoParallel(cl = temp.cluster)
    on.exit(parallel::stopCluster(cl = temp.cluster))

  }

  #parallelized loop
  spatial.predictors.i <- NULL
  spatial.predictors.order <- foreach::foreach(
    spatial.predictors.i = 1:ncol(spatial.predictors.df),
    .combine = "rbind"
    ) %dopar% {

    #3.2.3.1 preparing data

    #spatial predictor name
    spatial.predictors.name.i <- colnames(spatial.predictors.df)[spatial.predictors.i]

    #computing reduction in Moran's I
    if(ranking.method == "effect"){

      #training data
      data.i <- data.frame(
        data,
        spatial.predictors.df[, spatial.predictors.i]
      )
      colnames(data.i)[ncol(data.i)] <- spatial.predictors.name.i

      #new predictor.variable.names
      predictor.variable.names.i <- c(predictor.variable.names, spatial.predictors.name.i)

      #fitting model I
      m.i <- spatialRF::rf(
        data = data.i,
        dependent.variable.name = dependent.variable.name,
        predictor.variable.names = predictor.variable.names.i,
        seed = spatial.predictors.i,
        distance.matrix = distance.matrix,
        distance.thresholds = distance.thresholds,
        scaled.importance = FALSE,
        ranger.arguments = ranger.arguments,
        verbose = FALSE
      )

      #out.df
      out.i <- data.frame(
        spatial.predictors.name = spatial.predictors.name.i,
        model.r.squared = m.i$performance$r.squared,
        moran.i = m.i$spatial.correlation.residuals$max.moran,
        p.value = m.i$spatial.correlation.residuals$per.distance$p.value[1],
        ranking.criteria = reference.moran.i - m.i$spatial.correlation.residuals$max.moran
      )

    }

    #computing Moran's I of the spatial predictors
    if(ranking.method == "moran"){

      #moran's I of spatial predictor
      m.i <- spatialRF::moran(
        x = spatial.predictors.df[, spatial.predictors.i],
        distance.matrix = distance.matrix,
        distance.threshold = distance.thresholds[1]
      )

      #out.df
      out.i <- data.frame(
        spatial.predictors.name = spatial.predictors.name.i,
        ranking.criteria = m.i$moran.i
      )

    }

    #returning output
    return(out.i)

  } #end of parallelized loop

  #order dataframe
  ranking.criteria <- NULL
  spatial.predictors.order <- dplyr::arrange(
    spatial.predictors.order,
    dplyr::desc(ranking.criteria)
    )

  #return output
  out.list <- list()
  out.list$method <- ranking.method
  out.list$criteria <- spatial.predictors.order
  out.list$ranking <- spatial.predictors.order$spatial.predictors.name

  #returning output list
  out.list

}

