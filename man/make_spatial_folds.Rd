% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_spatial_folds.R
\name{make_spatial_folds}
\alias{make_spatial_folds}
\title{make_spatial_folds}
\usage{
make_spatial_folds(
  xy.selected = NULL,
  xy = NULL,
  distance.step = NULL,
  training.fraction = 0.6,
  n.cores = NULL
)
}
\arguments{
\item{xy.selected}{data frame with at least three columns: "x" (longitude), "y" (latitude), and "id" (integer, id of the record). Usually a subset of 'xy' obtained with \link{thinning} or \link{thinning_til_n} to avoid redundant spatial folds (happen when the origin points are too close to each other). Default: \code{NULL}.}

\item{xy}{data frame with at least three columns: "x" (longitude), "y" (latitude), and "id" (integer, index of the record). Default: \code{NULL}.}

\item{distance.step}{numeric, distance the buffer around xy.i is grown on each iteration. If NULL, it defaults to the minimum distance between points in xy divided by 2. Default: \code{NULL}.}

\item{training.fraction}{numeric, fraction of the data to be included in the growing buffer as training data, Default: 0.6}

\item{n.cores}{number of cores to use to generate spatial folds in parallel. Default: \code{NULL}.}
}
\value{
a list with as many slots as rows are in \emph{xy.selected}. Each slot has TWO slots named \strong{training} and \strong{testing}, with the former having the indices of the training records selected from xy, and the latter having the indices of the testing records.
}
\description{
it applies \link{make_spatial_fold} to every record in a data frame 'xy.selected' (generally the result of applying \link{thinning} or \link{thinning_til_n} to 'xy') to generate as many spatially independent folds over the dataset 'xy' as rows are in ''xy.selected'.
}
\examples{
 data(plant_richness_df)
 xy <- plant_richness_df[, 1:3]
 colnames(xy) <- c("id", "x", "y")
 xy.selected <- thinning_til_n(
   xy = xy,
   n = 20
   )
 out <- make_spatial_folds(
   xy.selected = xy.selected,
   xy = xy,
   distance.step = 0.05, #degrees
   training.fraction = 0.6,
   n.cores = 1
 )

 length(out)

 plot(xy[ c("x", "y")], type = "n", xlab = "", ylab = "")
 #plots training points
 points(xy[out[[10]]$training, c("x", "y")], col = "red4", pch = 15)
 #plots testing points
 points(xy[out[[10]]$testing, c("x", "y")], col = "blue4", pch = 15)
 #plots xy.i
 points(xy[10, c("x", "y")], col = "black", pch = 15, cex = 2)
}
