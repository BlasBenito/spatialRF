% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rf.R
\name{rf}
\alias{rf}
\title{Random forest models with Moran's I test of the residuals}
\usage{
rf(
  model = NULL,
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  xy = NULL,
  ranger.arguments = NULL,
  scaled.importance = FALSE,
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
}
\arguments{
\item{model}{(required if \code{data} is \code{NULL}; model produced with \code{spatialRF}) A model fitted with \code{\link[=rf]{rf()}}. If provided, it overrides all other input arguments (these are: \code{data}, \code{dependent.variable.name}, \code{predictor.variable.names}, \code{distance.matrix}, \code{distance.thresholds}, \code{xy}). However, you can provide new execution arguments and hyperparameters (like: \code{num.trees}, \code{mtry}, and any other argument accepted by the function \code{ranger::ranger()}) via the argument \code{ranger.arguments}. Default: \code{NULL}.}

\item{data}{(required if \code{model} is \code{NULL}; data frame or tibble) Data frame with a response variable and a set of predictors. If \code{data} is a tibble, all data frames in the output model are coerced to tibble. Default: \code{NULL}}

\item{dependent.variable.name}{(required if \code{model} is \code{NULL}; character string) Character string with the name of the response variable. Must be in the column names of \code{data}. If the dependent variable is binary with values 1 and 0, the argument \code{case.weights} of \code{ranger} is populated by the function \code{\link[=case_weights]{case_weights()}}. Default: \code{NULL}}

\item{predictor.variable.names}{(required if \code{model} is \code{NULL}; character vector with column names of \code{data}) Character vector with the names of the predictive variables. Every element of this vector must be in the column names of \code{data}. Optionally, the result of \code{\link[=auto_cor]{auto_cor()}} or \code{\link[=auto_vif]{auto_vif()}}. Default: \code{NULL}}

\item{distance.matrix}{(optional; distance matrix) Squared matrix with the distances among the records in \code{data}. The number of rows of \code{distance.matrix} and \code{data} must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: \code{NULL}}

\item{distance.thresholds}{(optional; numeric vector with distances in the same units as \code{distance.matrix}) Numeric vector with neighborhood distances. All distances in the distance matrix below each value in \code{dustance.thresholds} are set to 0 for the computation of Moran's I. If \code{NULL}, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: \code{NULL}}

\item{xy}{(optional; data frame, tibble, or matrix) Data frame or matrix with two columns containing coordinates and named "x" and "y". It is not used by this function, but it is stored in the slot \code{ranger.arguments$xy} of the model, so it can be used by \code{\link[=rf_evaluate]{rf_evaluate()}} and \code{\link[=rf_tuning]{rf_tuning()}}. Default: \code{NULL}}

\item{ranger.arguments}{(optional; list with ranger::ranger() arguments) Named list with \link[ranger]{ranger} arguments. All \link[ranger]{ranger} arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. The ranger arguments \code{x}, \code{y}, and \code{formula} are disabled. Please, consult the help file of \link[ranger]{ranger} if you are not familiar with the arguments of this function. Default: \code{NULL}.}

\item{scaled.importance}{(optional; logical) If \code{TRUE}, the function scales \code{data} with \link[base]{scale} and fits a new model to compute scaled variable importance scores. This makes variable importance scores of different models somewhat comparable. Default: \code{FALSE}}

\item{seed}{(optional; integer) Random seed to facilitate reproducibility. If set to a given number, the returned model is always the same. Default: \code{1}}

\item{verbose}{(optional; logical) If TRUE, messages and plots generated during the execution of the function are displayed. Default: \code{TRUE}}

\item{n.cores}{(optional; integer) Number of cores to use. Default: \code{parallel::detectCores() - 1}}

\item{cluster}{(optional; cluster object) A cluster definition generated with \code{parallel::makeCluster()} or \code{\link{start_cluster}}. Only advisable if you need to spread a large number of repetitions over the nodes of a large cluster when working with large data. If provided, overrides \code{n.cores}. The function does not stop a cluster, please remember to shut it down with \code{parallel::stopCluster(cl = cluster_name)} or \code{spatialRF::stop_cluster()} at the end of your pipeline. Default: \code{NULL}}
}
\value{
A ranger model with several extra slots:
\itemize{
\item \code{ranger.arguments}: Stores the values of the arguments used to fit the ranger model.
\item \code{predictions}: Predicted values.
\itemize{
\item \code{ib}: Numeric vector, predictions computed on the in-bag data.
\item \code{oob}: Numeric vector, predictions computed on the out-of-bag data.
}
\item \code{importance}: A list containing a data frame with the predictors ordered by their importance, a ggplot showing the importance values, and local importance scores (difference in accuracy between permuted and non permuted variables for every case, computed on the out-of-bag data).
\item \code{performance}: Performance scores computed on the in-bag and out-of-bag data. These performance scores can be highly inflated (especially the "in-bag" ones!)  if the spatial structure of the training data is strong, so I beg you to never report these as the actual performance metrics of your models, and advise you to use \code{\link[=rf_evaluate]{rf_evaluate()}} instead. In any case, if you wish to proceed, these are the metrics provided in this slot:
\itemize{
\item \code{r.squared.oob}: R-squared computed on the out-of-bag predictions using the expression \code{cor(observed, predicted.oob) ^ 2}.
\item \code{rmse.oob}: Root mean squared error computed on the out-of-bag predictions using the expression \code{spatialRF::root_mean_squared_error(o = observed, p = predicted.oob)}.
\item \code{nrmse.oob}: Normalized rood mean squared error computed on the out-of-bag data using the expression \code{spatialRF::root_mean_squared_error(o = observed, p = predicted.oob, normalization = "iq")}.
\item \code{auc.oob}: Only for binary responses with values 0 and 1. Area under the ROC curve computed on the out-of-bag predictions using the expression \code{spatialRF::auc(o = observed, p = predicted.oob)}.
\item \code{r.squared.ib}: R-squared computed on the in-bag predictions using the expression \code{cor(observed, predicted.ib) ^ 2}.
\item \code{rmse.ib}: Root mean squared error computed on the in-bag predictions using the expression \code{spatialRF::root_mean_squared_error(o = observed, p = predicted.ib)}.
\item \code{nrmse.ib}: Normalized rood mean squared error computed on the in-bag data using the expression \code{spatialRF::root_mean_squared_error(o = observed, p = predicted.ib, normalization = "iq")}.
\item \code{auc.ib}: Only for binary responses with values 0 and 1. Area under the ROC curve computed on the in-bag predictions using the expression \code{spatialRF::auc(o = observed, p = predicted.ib)}.
}
\item \code{residuals}: residuals, normality test of the residuals computed with \code{\link[=residuals_test]{residuals_test()}}, and spatial autocorrelation of the residuals computed with \code{\link[=moran_multithreshold]{moran_multithreshold()}}.
}
}
\description{
A convenient wrapper for \link[ranger]{ranger} that completes its output by providing the Moran's I of the residuals for different distance thresholds, the rmse and nrmse (as computed by \code{\link[=root_mean_squared_error]{root_mean_squared_error()}}), and variable importance scores based on a scaled version of the data generated by \link[base]{scale}.
}
\details{
Please read the help file of \link[ranger]{ranger} for further details. Notice that the \code{formula} interface of \link[ranger]{ranger} is supported through \code{ranger.arguments}, but variable interactions are not allowed (but check \code{\link[=the_feature_engineer]{the_feature_engineer()}}).
}
\examples{
if(interactive()){

 #loading example data
 data(
  ecoregions_df,
  ecoregions_distance_matrix,
  ecoregions_predictor_variable_names,
  ecoregions_dependent_variable_name
  )

 #fitting random forest model
 out <- rf(
   data = ecoregions_df,
   dependent.variable.name = ecoregions_dependent_variable_name,
   predictor.variable.names = ecoregions_predictor_variable_names,
   distance.matrix = ecoregions_distance_matrix,
   distance.thresholds = 0,
   n.cores = 1
 )

 class(out)

 #data frame with ordered variable importance
 out$importance$per.variable

 #variable importance plot
 out$importance$per.variable.plot

 #performance
 out$performance

 #spatial correlation of the residuals
 out$spatial.correlation.residuals$per.distance

 #plot of the Moran's I of the residuals for different distance thresholds
 out$spatial.correlation.residuals$plot

 #predictions for new data as done with ranger models:
 predicted <- stats::predict(
   object = out,
   data = ecoregions_df,
   type = "response"
 )$predictions


 #re-fitting a model with different hyperparameters
 ###################################################
 out.custom <- rf(
   model = out,
   ranger.arguments = list(
     num.trees = 5000,
     mtry = 3,
     min.node.size = 10
   )
 )

 #alternative data input methods
 ###############################

 #ranger.arguments
 my.ranger.arguments <- list(
 data = ecoregions_df,
 dependent.variable.name = ecoregions_dependent_variable_name,
 predictor.variable.names = ecoregions_predictor_variable_names,
 distance.matrix = ecoregions_distance_matrix,
 distance.thresholds = c(0, 1000)
 )

 #fitting model with these ranger arguments
 out <- rf(
   ranger.arguments = my.ranger.arguments,
   n.cores = 1
   )

}
}
