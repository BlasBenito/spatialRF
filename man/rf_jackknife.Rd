% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rf_jackknife.R
\name{rf_jackknife}
\alias{rf_jackknife}
\title{Jackknife test of variable importance via spatial cross-validation}
\usage{
rf_jackknife(
  model = NULL,
  xy = NULL,
  repetitions = 30,
  training.fraction = 0.75,
  distance.step = NULL,
  fill.color = viridis::viridis(3, option = "F", direction = 1, alpha = 1, end = 0.9),
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
}
\arguments{
\item{model}{Model fitted with \code{\link[=rf]{rf()}} and/or \code{\link[=rf_spatial]{rf_spatial()}}. The function doesn't work with models fitted with \code{\link[=rf_repeat]{rf_repeat()}}. Default: \code{NULL}}

\item{xy}{Data frame or matrix with two columns containing coordinates and named "x" and "y". If \code{NULL}, the function will throw an error. Default: \code{NULL}}

\item{repetitions}{Integer, number of spatial folds to use during cross-validation. Must be lower than the total number of rows available in the model's data. Default: \code{30}}

\item{training.fraction}{Proportion between 0.5 and 0.9 indicating the proportion of records to be used as training set during spatial cross-validation. Default: \code{0.75}}

\item{distance.step}{(optional; numeric) Numeric vector of length one or two. Distance step used during the growth of the buffer containing the training cases. Must be in the same units as the coordinates in \code{xy}. When only one distance is provided, the same growth is applied to the x and y axes. If two distances are provided, the first one is applied to the x axis, and the second one to the y. When \code{NULL}, it uses 1/1000th of the range of each axis as distance. The smaller this number is, the easier is to achieve an accurate \code{training.fraction}, but the slower the algorithm becomes. Default: \code{NULL}}

\item{fill.color}{Character vector with hexadecimal codes (e.g. "#440154FF" "#21908CFF" "#FDE725FF"), or function generating a palette (e.g. \code{viridis::viridis(100)}). Default: \code{viridis::viridis(100, option = "F", direction = -1, alpha = 0.8, end = 0.9)}}

\item{seed}{Integer, random seed to facilitate reproduciblity. If set to a given number, the results of the function are always the same. Default: \code{1}.}

\item{verbose}{Logical. If \code{TRUE}, messages and plots generated during the execution of the function are displayed, Default: \code{TRUE}}

\item{n.cores}{Integer, number of cores used by \code{\link[ranger]{ranger}} for parallel execution (used as value for the argument \code{num.threads} in \code{ranger()}). Default: \code{parallel::detectCores() - 1}}

\item{cluster}{A cluster definition generated with \code{parallel::makeCluster()} or \code{\link{start_cluster}}. Faster than using \code{n.cores} for smaller models. If provided, overrides \code{n.cores}. The function does not stop a cluster, please remember to shut it down with \code{parallel::stopCluster(cl = cluster_name)} or \code{\link{stop_cluster}} at the end of your pipeline. Default: \code{NULL}}
}
\value{
The input model with new slot named "jackknife". This is a list with slots named after the metrics introduced in the argument \code{metrics}. For example, if one of the metrics used is "r.squared", then the plot of this metric will be in \code{model$jackknife$r.squared$plot}, and the dataframe used to build the plot will be in \code{model$jackknife$r.squared$df}.
}
\description{
Fits and evaluates (via spatial cross-validation with \code{\link[=rf_evaluate]{rf_evaluate()}}) models with and without each predictor to compute a jackknife-based importance score. The predictors are ranked according to the difference in performance between models fitted only with (univariate models) and without the predictor (all predictors but the given one).
}
\details{
Model evaluation is based on spatial cross-validation. If the response is numeric, the R-squared is used, but if the response is binary (with values 1 and 0), then AUC is used instead.
}
\examples{
if(interactive()){

#loading example data
data(
  ecoregions_df,
  ecoregions_distance_matrix,
  ecoregions_predictor_variable_names,
  ecoregions_dependent_variable_name
  )

  cluster <- start_cluster()

#fitting random forest model
rf.model <- rf(
  data = ecoregions_df,
  dependent.variable.name = ecoregions_dependent_variable_name,
  predictor.variable.names = ecoregions_predictor_variable_names,
  distance.matrix = ecoregions_distance_matrix,
  distance.thresholds = 0,
  xy = ecoregions_df[, c("x", "y")],
  n.cores = 1,
  verbose = FALSE
)

#computing predictor contribution to model transferability
rf.model <- rf_jackknife(
  model = rf.model,
  cluster = cluster,
  verbose = TRUE
  )

stop_cluster(cluster)

#accessing results
rf.model$jackknife$r.squared$df
rf.model$jackknife$r.squared$plot

}

}
