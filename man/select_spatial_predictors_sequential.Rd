% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/select_spatial_predictors_sequential.R
\name{select_spatial_predictors_sequential}
\alias{select_spatial_predictors_sequential}
\title{select_spatial_predictors_sequential}
\usage{
select_spatial_predictors_sequential(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  spatial.predictors.ranking = NULL,
  n.cores = NULL,
  cluster.ips = NULL,
  cluster.cores = NULL,
  cluster.user = NULL,
  cluster.port = 11000
)
}
\arguments{
\item{data}{(required) data frame with a response variable and a set of (preferably uncorrelated) predictors, Default: NULL}

\item{dependent.variable.name}{(required) string with the name of the response variable. Must be in the column names of 'data', Default: NULL}

\item{predictor.variable.names}{(required) character vector with the names of the predictive variables. Every element must be in the column names of 'data', Default: NULL}

\item{distance.matrix}{(optional) a squared matrix with the distances among the records in 'data'. Notice that the rows of 'distance.matrix' and 'data' must be the same. If not provided, the computation of the Moran's I of the residuals is ommited. Default: NULL.}

\item{distance.thresholds}{(optional) numeric vector, distances below each value in the distance matrix are set to 0 for the computation of Moran's I. If NULL, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: NULL.}

\item{ranger.arguments}{list with \link[ranger]{ranger} arguments. See \link{rf} or \link{rf_repeat} for further details.}

\item{spatial.predictors.df}{data frame of spatial predictors, either a distance matrix, or the PCA factors of the distance matrix produced by \link{pca_multithreshold}.}

\item{spatial.predictors.ranking}{ranking of predictors returned by \link{rank_spatial_predictors}.}

\item{n.cores}{number of cores to use to compute repetitions. If NULL, all cores but one are used, unless a cluster is used.}

\item{cluster.ips}{character vector, IPs of the machines in the cluster. The first machine will be considered the main node of the cluster, and will generally be the machine on which the R code is being executed.}

\item{cluster.cores}{numeric integer vector, number of cores on each machine.}

\item{cluster.user}{character string, name of the user (should be the same throughout machines), Defaults to the current system user. Default: user name of the current session.}

\item{cluster.port}{integer, port used by the machines in the cluster to communicate. The firewall in all computers must allow traffic from and to such port. Default: 11000.}
}
\value{
a list with two slots: \code{optimization}, a data frame with the index of the spatial predictor added on each iteration, the spatial correlation of the model residuals, and the R-squared of the model, and \code{best.spatial.predictors}, that is a character vector with the names of the spatial predictors that minimize the Moran's I of the residuals and maximize the R-squared of the model.
}
\description{
selects spatial predictors (either a distance matrix or the PCA factors of a distance matrix) by adding them sequentially to a model while monitoring the spatial correlation of the model residuals and the R-squared. Once all the available spatial predictors have been added to the model, the function identifies the first n predictors that minimize the spatial correlation of the residuals and maximize R-squared, and returns the names of the selected spatial predictors and a data frame with the selection criteria.
}
\details{
How does the algorithm work? If the function \link{rank_spatial_predictors} returns 10 spatial predictors (sp1 to sp10, ordered from best to worst), \link{select_spatial_predictors_sequential} is going to fit the models \code{y ~ predictors + sp1}, \code{y ~ predictors + sp1 + sp2}, until all spatial predictors are used in \verb{y ~ predictors + sp1 ... sp10}. The model with lower Moran's I of the residuals and higher R-squared is selected, and its spatial predictors returned.
}
\examples{
\dontrun{
if(interactive()){
data("distance_matrix")
data("plant_richness_df")

#common arguments
data = plant_richness_df
dependent.variable.name = "richness_species_vascular"
predictor.variable.names = colnames(plant_richness_df)[5:21]
distance.matrix = distance_matrix
distance.thresholds = c(0, 100, 1000)

#non-spatial model
model <- rf(
  data = data,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds
)

#preparing spatial predictors
spatial.predictors <- pca_distance_matrix(
  x = distance.matrix,
  distance.thresholds = distance.thresholds
)
#ranking spatial predictors by their Moran's I (faster option)
spatial.predictors.ranking <- rank_spatial_predictors(
  ranking.method = "mem",
  spatial.predictors.df = spatial.predictors,
  reference.moran.i = model$spatial.correlation.residuals$max.moran,
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds,
  n.cores = 1,
  multicollinearity.filter = "vif"
)

#selecting the best subset of predictors
selection <- select_spatial_predictors_sequential(
  data = data,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds,
  spatial.predictors.df = spatial.predictors,
  spatial.predictors.ranking = spatial.predictors.ranking,
  n.cores = 1
)

selection$optimization
selection$best.spatial.predictors
 }
}
}
