#' @title rf
#' @description a convenient wrapper for \link[ranger]{ranger} that completes its output by providing the Moran's I of the residuals for different distance thresholds, the rmse and nrmse (as computed by [root_mean_squared_error]), and variable importance scores based on a scaled version of the data generated by [scale_robust].
#' @param data (required) data frame with a response variable and a set of (preferably uncorrelated) predictors, Default: NULL
#' @param dependent.variable.name (required) string with the name of the response variable. Must be in the column names of 'data', Default: NULL
#' @param predictor.variable.names (required) character vector with the names of the predictive variables. Every element must be in the column names of 'data', Default: NULL
#' @param distance.matrix (optional) a squared matrix with the distances among the records in 'data'. Notice that the rows of 'distance.matrix' and 'data' must be the same. If not provided, the computation of the Moran's I of the residuals is ommited. Default: NULL``
#' @param distance.thresholds (optional) numeric vector, distances below each value in the distance matrix are set to 0 for the computation of Moran's I. If NULL, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: NULL.
#' @param ranger.arguments (optional) list with \link[ranger]{ranger} arguments. All \link[ranger]{ranger} arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. Please, consult the help file of \link[ranger]{ranger} if you are not familiar with the arguments of this function.
#' @param trees.per.variable (optional) number of individual regression trees to fit per variable in 'predictor.variable.names'. This is an alternative way to define ranger's 'num.trees'. If NULL, 'num.trees' is 500. Default: NULL
#' @param scaled.importance (optional) boolean. If TRUE, and 'importance = "permutation', the function scales 'data' with [scale_robust] and fits a new model to compute scaled variable importance scores. Default: TRUE
#' @param seed (optional) integer, random seed to facilitate reproducibility, Default: NULL
#' @return a ranger model with several new slots:
#' \itemize{
#'   \item `ranger.arguments`: stores the values of the arguments used to fit the ranger model.
#'   \item `variable.importance`: a list containing the vector of variable importance as originally returned by ranger (scaled or not depending on the value of 'scaled.importance'), a data frame with the predictors ordered by their importance, and a ggplot showing the importance values.
#'   \item `pseudo.r.squared`: computed as the correlation between the observations and the predictions.
#'   \item `rmse`: as computed by [root_mean_squared_error] with 'normalization = NULL'.
#'   \item `nrmse`: as computed by [root_mean_squared_error] with 'normalization = "iq'.
#'   \item `residuals`: computed as observations minus predictions.
#'   \item `spatial.correlation.residuals`: the result of [moran_multithreshold].
#' }
#' @details Please read the help file of \link[ranger]{ranger} for further details.
#' @examples
#' \dontrun{
#' if(interactive()){
#'  data("plant_richness_df")
#'  data("distance_matrix")
#'  out <- rf(
#'    data = plant_richness_df,
#'    dependent.variable.name = "richness_species_vascular",
#'    predictor.variable.names = colnames(plant_richness_df)[5:21],
#'    distance.matrix = distance_matrix,
#'    distance.thresholds = c(0, 100, 1000, 10000)
#'  )
#'
#'  class(out)
#'
#'  #data frame with ordered variable importance
#'  out$variable.importance$df
#'
#'  #variable importance plot
#'  out$variable.importance$plot
#'
#'  #pseudo R-squared
#'  out$pseudo.r.squared
#'
#'  #rmse and nrmse
#'  out$rmse
#'  out$nrmse
#'
#'  #spatial correlation of the residuals for different distance thresholds
#'  out$spatial.correlation.residuals$df
#'
#'  #plot of the Moran's I of the residuals for different distance thresholds
#'  out$spatial.correlation.residuals$plot
#'  }
#' }
#' @rdname rf
#' @export
#' @importFrom parallel detectCores
#' @importFrom tibble remove_rownames
#' @importFrom dplyr arrange
#' @importFrom ggplot2 ggplot aes geom_point ylab
#' @importFrom stats formula reorder
#' @importFrom rlang .data
rf <- function(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = list(
    mtry = NULL,
    min.node.size = NULL,
    max.depth = NULL,
    importance = "permutation",
    scale.permutation.importance = TRUE,
    local.importance = FALSE,
    write.forest = TRUE,
    replace = TRUE,
    sample.fraction = ifelse(replace, 1, 0.632),
    case.weights = NULL,
    num.threads = parallel::detectCores() - 1,
    save.memory = FALSE,
    verbose = TRUE
  ),
  trees.per.variable = NULL,
  scaled.importance = TRUE,
  seed = NULL
){

  #subsetting data
  if(!is.null(data)){

    if(!is.null(predictor.variable.names) & !is.null(dependent.variable.name)){

      predictor.variable.names <- predictor.variable.names[predictor.variable.names %in% colnames(data)]
      data <- data[, c(dependent.variable.name, predictor.variable.names)]

    }

    #removing NA
    data <- na.omit(data)

  }

  #default arguments (needs to be here to avoid devtools::check() complaints)
  formula = NULL
  num.trees = 500
  trees.per.variable = NULL
  mtry = NULL
  mtry = NULL
  importance = "permutation"
  write.forest = TRUE
  probability = FALSE
  min.node.size = NULL
  max.depth = NULL
  replace = TRUE
  sample.fraction = ifelse(replace, 1, 0.632)
  case.weights = NULL
  class.weights = NULL
  splitrule = NULL
  num.random.splits = 1
  alpha = 0.5
  minprop = 0.1
  split.select.weights = NULL
  always.split.variables = NULL
  respect.unordered.factors = NULL
  scale.permutation.importance = TRUE
  local.importance = FALSE
  regularization.factor = 1
  regularization.usedepth = FALSE
  keep.inbag = FALSE
  inbag = NULL
  holdout = FALSE
  quantreg = FALSE
  oob.error = TRUE
  num.threads = parallel::detectCores() - 1
  save.memory = FALSE
  verbose = TRUE
  seed = NULL
  classification = NULL
  x = NULL
  y = NULL

  #user arguments
  if(!is.null(ranger.arguments)){
    list2env(ranger.arguments, envir=environment())
  }

  #setting up seed if available
  if(!is.null(seed)){
    set.seed(seed)
  }

  if(!is.null(trees.per.variable)){
    num.trees <- trees.per.variable * (ncol(data) - 1)
  }

  #ranger model for r-squared and predictions
  m <- ranger::ranger(
    data = data,
    dependent.variable.name = dependent.variable.name,
    num.trees = num.trees,
    mtry = mtry,
    importance = importance,
    write.forest = write.forest,
    probability = probability,
    min.node.size = min.node.size,
    max.depth = max.depth,
    replace = replace,
    sample.fraction = sample.fraction,
    case.weights = case.weights,
    class.weights = class.weights,
    splitrule = splitrule,
    num.random.splits = num.random.splits,
    alpha = alpha,
    minprop = minprop,
    split.select.weights = split.select.weights,
    always.split.variables = always.split.variables,
    respect.unordered.factors = respect.unordered.factors,
    scale.permutation.importance = scale.permutation.importance,
    local.importance = local.importance,
    regularization.factor = regularization.factor,
    regularization.usedepth = regularization.usedepth,
    keep.inbag = keep.inbag,
    inbag = inbag,
    holdout = holdout,
    quantreg = quantreg,
    oob.error = oob.error,
    num.threads = num.threads,
    save.memory = save.memory,
    verbose = verbose,
    seed = seed,
    classification = classification,
    x = x,
    y = y
  )

  #if scaled.importance is TRUE
  if(scaled.importance == TRUE){

    #applying robust scaling to the data
    data.scaled <- scale_robust(
      x = data
    )

    #if scaling fails, use regular scaling
    if(sum(is.nan(data.scaled[, 1])) > 0 | sum(is.infinite(data.scaled[, 1])) > 0){
      data.scaled <- as.data.frame(scale(data))
    }

    #ranger model for variable importance
    m.scaled <- ranger::ranger(
      data = data.scaled,
      dependent.variable.name = dependent.variable.name,
      num.trees = num.trees,
      mtry = mtry,
      importance = importance,
      write.forest = write.forest,
      probability = probability,
      min.node.size = min.node.size,
      max.depth = max.depth,
      replace = replace,
      sample.fraction = sample.fraction,
      case.weights = case.weights,
      class.weights = class.weights,
      splitrule = splitrule,
      num.random.splits = num.random.splits,
      alpha = alpha,
      minprop = minprop,
      split.select.weights = split.select.weights,
      always.split.variables = always.split.variables,
      respect.unordered.factors = respect.unordered.factors,
      scale.permutation.importance = FALSE,
      local.importance = local.importance,
      regularization.factor = regularization.factor,
      regularization.usedepth = regularization.usedepth,
      keep.inbag = keep.inbag,
      inbag = inbag,
      holdout = holdout,
      quantreg = quantreg,
      oob.error = oob.error,
      num.threads = num.threads,
      save.memory = save.memory,
      verbose = verbose,
      seed = seed,
      classification = classification,
      x = x,
      y = y
    )

  } else {

    m.scaled <- m

  }

  #adding model arguments
  m$ranger.arguments <- list(
    data = data,
    dependent.variable.name = dependent.variable.name,
    predictor.variable.names = predictor.variable.names,
    num.trees = num.trees,
    mtry = mtry,
    importance = importance,
    write.forest = write.forest,
    probability = probability,
    min.node.size = min.node.size,
    max.depth = max.depth,
    replace = replace,
    sample.fraction = sample.fraction,
    case.weights = case.weights,
    class.weights = class.weights,
    splitrule = splitrule,
    num.random.splits = num.random.splits,
    alpha = alpha,
    minprop = minprop,
    split.select.weights = split.select.weights,
    always.split.variables = always.split.variables,
    respect.unordered.factors = respect.unordered.factors,
    scale.permutation.importance = scale.permutation.importance,
    local.importance = local.importance,
    regularization.factor = regularization.factor,
    regularization.usedepth = regularization.usedepth,
    keep.inbag = keep.inbag,
    inbag = inbag,
    holdout = holdout,
    quantreg = quantreg,
    oob.error = oob.error,
    num.threads = num.threads,
    save.memory = save.memory,
    verbose = verbose,
    seed = seed,
    classification = classification
  )

  #importance dataframe
  importance.vector <- m.scaled$variable.importance
  m$variable.importance <- list()
  m$variable.importance$vector <- importance.vector
  m$variable.importance$df <- data.frame(
    variable = names(m.scaled$variable.importance),
    importance = m.scaled$variable.importance
  ) %>%
    tibble::remove_rownames() %>%
    dplyr::arrange(dplyr::desc(importance))

  m$variable.importance$plot <- ggplot2::ggplot(data = m$variable.importance$df) +
    ggplot2::aes(
      x = importance,
      y = reorder(
        .data$variable,
        .data$importance,
        FUN = max
      )
    ) +
    ggplot2::geom_point(size = 2) +
    ggplot2::ylab("")

  #getting residuals

  #predicted data
  predicted <- m$predictions

  #getting observed data

  #if data is provided
  if(!is.null(data)){

    #the user used a formula
    if(!is.null(formula)){

      #observed
      observed <- data[, all.vars(formula)[1]]

    }

    #user gave dependent.variable.name
    if(!is.null(dependent.variable.name)){

      #observed
      observed <- data[, dependent.variable.name]

    }

  }

  if(!is.null(y) & !is.null(x)){

    observed = y

  }

  m$pseudo.r.squared <- cor(
    observed,
    predicted
  )

  m$rmse <- root_mean_squared_error(
    o = observed,
    p = predicted,
    normalization = NULL
  )

  m$nrmse <- root_mean_squared_error(
    o = observed,
    p = predicted,
    normalization = "iq"
  )

  m$residuals <- observed - predicted


  #compute moran I of residuals if distance.matrix is provided
  if(!is.null(distance.matrix)){

    m$spatial.correlation.residuals <- moran_multithreshold(
      x = m$residuals,
      distance.matrix = distance.matrix,
      distance.thresholds = distance.thresholds,
      plot = FALSE
    )

  }

  #replacing local variable importance with the scaled one
  if(local.importance == TRUE){
    m$variable.importance.local <- m.scaled$variable.importance.local
  }

  #return model
  m

}
