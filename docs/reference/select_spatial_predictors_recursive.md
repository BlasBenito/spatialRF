# Finds optimal combinations of spatial predictors

Selects spatial predictors following these steps:

1.  Gets the spatial predictors ranked by
    [`rank_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.md)
    and fits a model of the form
    `y ~ predictors + best_spatial_predictor_1`. The Moran's I of the
    residuals of this model is used as reference value for the next
    step.

2.  The remaining spatial predictors are introduced again into
    [`rank_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.md),
    and the spatial predictor with the highest ranking is introduced in
    a new model of the form
    `y ~ predictors + best_spatial_predictor_1 + best_spatial_predictor_2`.

3.  Steps 1 and 2 are repeated until the Moran's I doesn't improve for a
    number of repetitions equal to the 20 percent of the total number of
    spatial predictors introduced in the function.

This method allows to select the smallest set of spatial predictors that
have the largest joint effect in reducing the spatial correlation of the
model residuals, while maintaining the model's R-squared as high as
possible. As a consequence of running
[`rank_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.md)
on each iteration, this method includes less spatial predictors in the
final model than the sequential method implemented in
[`select_spatial_predictors_sequential()`](https://blasbenito.github.io/spatialRF/reference/select_spatial_predictors_sequential.md)
would do, while minimizing spatial correlation and maximizing the R
squared of the model as much as possible.

## Usage

``` r
select_spatial_predictors_recursive(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  spatial.predictors.ranking = NULL,
  weight.r.squared = 0.25,
  weight.penalization.n.predictors = 0,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
)
```

## Arguments

- data:

  Data frame with a response variable and a set of predictors. Default:
  `NULL`

- dependent.variable.name:

  Character string with the name of the response variable. Must be in
  the column names of `data`. Default: `NULL`

- predictor.variable.names:

  Character vector with the names of the predictive variables. Every
  element of this vector must be in the column names of `data`. Default:
  `NULL`

- distance.matrix:

  Squared matrix with the distances among the records in `data`. The
  number of rows of `distance.matrix` and `data` must be the same. If
  not provided, the computation of the Moran's I of the residuals is
  omitted. Default: `NULL`

- distance.thresholds:

  Numeric vector with neighborhood distances. All distances in the
  distance matrix below each value in `dustance.thresholds` are set to 0
  for the computation of Moran's I. If `NULL`, it defaults to seq(0,
  max(distance.matrix), length.out = 4). Default: `NULL`

- ranger.arguments:

  Named list with
  [ranger](http://imbs-hl.github.io/ranger/reference/ranger.md)
  arguments (other arguments of this function can also go here). All
  [ranger](http://imbs-hl.github.io/ranger/reference/ranger.md)
  arguments are set to their default values except for 'importance',
  that is set to 'permutation' rather than 'none'. Please, consult the
  help file of
  [ranger](http://imbs-hl.github.io/ranger/reference/ranger.md) if you
  are not familiar with the arguments of this function.

- spatial.predictors.df:

  Data frame of spatial predictors.

- spatial.predictors.ranking:

  Ranking of predictors returned by
  [`rank_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.md).

- weight.r.squared:

  Numeric between 0 and 1, weight of R-squared in the optimization
  index. Default: `0.25`

- weight.penalization.n.predictors:

  Numeric between 0 and 1, weight of the penalization for the number of
  spatial predictors added in the optimization index. Default: `0`

- n.cores:

  Integer, number of cores to use. Default:
  `parallel::detectCores() - 1`

- cluster:

  A cluster definition generated by
  [`parallel::makeCluster()`](https://rdrr.io/r/parallel/makeCluster.html).
  Default: `NULL`

## Value

A list with two slots: `optimization`, a data frame with the index of
the spatial predictor added on each iteration, the spatial correlation
of the model residuals, and the R-squared of the model, and
`best.spatial.predictors`, that is a character vector with the names of
the spatial predictors that minimize the Moran's I of the residuals and
maximize the R-squared of the model.

## Details

The algorithm works as follows. If the function
[`rank_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.md)
returns 10 ranked spatial predictors (sp1 to sp10, being sp7 the best
one), `select_spatial_predictors_recursive()` is going to first fit the
model `y ~ predictors + sp7`. Then, the spatial predictors sp2 to sp9
are again ranked with
[`rank_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.md)
using the model `y ~ predictors + sp7` as reference (at this stage, some
of the spatial predictors might be dropped due to lack of effect). When
the new ranking of spatial predictors is ready (let's say they are sp5,
sp3, and sp4), the best one (sp5) is included in the model
`y ~ predictors + sp7 + sp5`, and the remaining ones go again to
[`rank_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.md)
to repeat the process until spatial predictors are depleted.

## See also

Other spatial_analysis:
[`filter_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/filter_spatial_predictors.md),
[`mem()`](https://blasbenito.github.io/spatialRF/reference/mem.md),
[`mem_multithreshold()`](https://blasbenito.github.io/spatialRF/reference/mem_multithreshold.md),
[`moran()`](https://blasbenito.github.io/spatialRF/reference/moran.md),
[`moran_multithreshold()`](https://blasbenito.github.io/spatialRF/reference/moran_multithreshold.md),
[`pca()`](https://blasbenito.github.io/spatialRF/reference/pca.md),
[`pca_multithreshold()`](https://blasbenito.github.io/spatialRF/reference/pca_multithreshold.md),
[`rank_spatial_predictors()`](https://blasbenito.github.io/spatialRF/reference/rank_spatial_predictors.md),
[`residuals_diagnostics()`](https://blasbenito.github.io/spatialRF/reference/residuals_diagnostics.md),
[`residuals_test()`](https://blasbenito.github.io/spatialRF/reference/normality.md),
[`select_spatial_predictors_sequential()`](https://blasbenito.github.io/spatialRF/reference/select_spatial_predictors_sequential.md)

## Examples

``` r
if (interactive()) {
  data(
    plants_df,
    plants_response,
    plants_predictors,
    plants_distance,
    plants_rf
  )

  #subset to speed up example
  idx <- 1:20
  plants_df <- plants_df[idx, ]
  plants_distance <- plants_distance[idx, idx]

  #generate spatial predictors
  mems <- mem_multithreshold(
    distance.matrix = plants_distance,
    distance.thresholds = 100
  )

  #rank them from higher to lower moran
  mems.rank <- rank_spatial_predictors(
    ranking.method = "moran",
    spatial.predictors.df = mems,
    reference.moran.i = plants_rf$residuals$autocorrelation$max.moran,
    distance.matrix = plants_distance,
    distance.thresholds = 100,
    n.cores = 1
  )

  #select best subset via sequential addition
  selection <- select_spatial_predictors_recursive(
    data = plants_df,
    dependent.variable.name = plants_response,
    predictor.variable.names = plants_predictors,
    distance.matrix = plants_distance,
    distance.thresholds = 0,
    spatial.predictors.df = mems,
    spatial.predictors.ranking = mems.rank,
    ranger.arguments = list(num.trees = 30),
    n.cores = 1
  )

  #names of selected spatial predictors
  selection$best.spatial.predictors

  #optimization plot
  plot_optimization(selection$optimization)
}
```
