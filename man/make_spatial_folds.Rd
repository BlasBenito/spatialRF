% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/make_spatial_folds.R
\name{make_spatial_folds}
\alias{make_spatial_folds}
\title{Create multiple spatially independent training and testing folds}
\usage{
make_spatial_folds(
  data = NULL,
  dependent.variable.name = NULL,
  xy.selected = NULL,
  xy = NULL,
  distance.step = NULL,
  distance.step.x = NULL,
  distance.step.y = NULL,
  training.fraction = 0.75
)
}
\arguments{
\item{data}{Data frame containing response variable and predictors. Required only for binary response variables.}

\item{dependent.variable.name}{Character string with the name of the response variable. Must be a column name in \code{data}. Required only for binary response variables.}

\item{xy.selected}{Data frame with columns "x" (longitude), "y" (latitude), and "id" (record identifier). Defines the focal points for fold creation. Typically a spatially thinned subset of \code{xy} created with \code{\link[=thinning]{thinning()}} or \code{\link[=thinning_til_n]{thinning_til_n()}}.}

\item{xy}{Data frame with columns "x" (longitude), "y" (latitude), and "id" (record identifier). Contains all spatial coordinates for the dataset.}

\item{distance.step}{Numeric value specifying the buffer growth increment. Applied to the longer axis of the coordinate bounding box; shorter axis step is calculated proportionally to maintain aspect ratio. Default: \code{NULL} (automatically set to 1/1000th of range independently per axis). Replaces deprecated distance.step.x/distance.step.y arguments.}

\item{distance.step.x}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}} Use distance.step instead.}

\item{distance.step.y}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#deprecated}{\figure{lifecycle-deprecated.svg}{options: alt='[Deprecated]'}}}{\strong{[Deprecated]}} Use distance.step instead.}

\item{training.fraction}{Numeric value between 0.1 and 0.9 specifying the fraction of records to include in the training fold. Default: \code{0.75}.}
}
\value{
Data frame with \code{nrow(xy)} rows and \code{nrow(xy.selected)} columns. Each column is a logical vector representing one fold, where \code{TRUE} indicates a record is in the training set and \code{FALSE} indicates it is in the testing set for that fold. Column names are \code{fold_1}, \code{fold_2}, etc.
}
\description{
Applies \code{\link[=make_spatial_fold]{make_spatial_fold()}} to every row in \code{xy.selected}, generating one spatially independent fold centered on each focal point. Used for spatial cross-validation in \code{\link[=rf_evaluate]{rf_evaluate()}}.
}
\details{
This function creates multiple spatially independent folds for spatial cross-validation by calling \code{\link[=make_spatial_fold]{make_spatial_fold()}} once for each row in \code{xy.selected}. Each fold is created by growing a rectangular buffer from the corresponding focal point until the desired \code{training.fraction} is achieved.

\strong{Parallel execution:}

The function uses the future ecosystem for parallelization. Control the parallel strategy externally via \code{future::plan()}:
\itemize{
\item \code{future::plan(future::sequential)} - No parallelization (default)
\item \code{future::plan(future::multisession, workers = 4)} - Parallel execution with 4 workers
\item \code{future::plan(future::multicore, workers = 4)} - Fork-based (Unix/Mac only)
}

\strong{Progress reporting:}

This function supports progress bars via the progressr package. To enable progress reporting, set handlers before calling the function:
\itemize{
\item \code{progressr::handlers(global = TRUE)} - Enable progress bars for all functions
\item \code{progressr::handlers("progress")} - Use a specific handler type
}

\strong{Typical workflow:}
\enumerate{
\item Thin spatial points with \code{\link[=thinning]{thinning()}} or \code{\link[=thinning_til_n]{thinning_til_n()}} to create \code{xy.selected}
\item Optionally configure parallel plan with \code{future::plan()}
\item Optionally enable progress bars with \code{progressr::handlers(global = TRUE)}
\item Create spatial folds with this function
\item Use the folds for spatial cross-validation in \code{\link[=rf_evaluate]{rf_evaluate()}}
}
}
\examples{
data(plants_df, plants_xy)

# Thin to 10 focal points to speed up example
xy.thin <- thinning_til_n(
  xy = plants_xy,
  n = 10
)

# Basic usage - sequential execution
folds <- make_spatial_folds(
  xy.selected = xy.thin,
  xy = plants_xy,
  distance.step = 0.05,
  training.fraction = 0.6
)

# Each column is a fold with logical values (TRUE = training)
dim(folds)  # 800 rows Ã— 10 columns (10 folds)
colnames(folds)  # "fold_1", "fold_2", ..., "fold_10"
sum(folds[, 1])  # Number of training records in first fold

\donttest{
# With progress bars and parallel execution
library(future)
library(progressr)

# Enable progress reporting
progressr::handlers(global = TRUE)

# Set parallel strategy
future::plan(future::multisession, workers = 2)

# Create folds with progress bars
folds_parallel <- make_spatial_folds(
  xy.selected = xy.thin,
  xy = plants_xy,
  distance.step = 0.05,
  training.fraction = 0.6
)

# Reset to sequential
future::plan(future::sequential)
}

# Visualize first fold (training = red, testing = blue, center = black)
if (interactive()) {
  plot(plants_xy[c("x", "y")], type = "n", xlab = "", ylab = "")
  points(plants_xy[folds[, 1], c("x", "y")], col = "red4", pch = 15)
  points(plants_xy[!folds[, 1], c("x", "y")], col = "blue4", pch = 15)
  points(
    plants_xy[which(folds[, 1])[1], c("x", "y")],
    col = "black",
    pch = 15,
    cex = 2
  )
}

}
\seealso{
\code{\link[=make_spatial_fold]{make_spatial_fold()}}, \code{\link[=rf_evaluate]{rf_evaluate()}}, \code{\link[=thinning]{thinning()}}, \code{\link[=thinning_til_n]{thinning_til_n()}}

Other preprocessing: 
\code{\link{default_distance_thresholds}()},
\code{\link{distance_matrix}()},
\code{\link{double_center_distance_matrix}()},
\code{\link{is_binary}()},
\code{\link{make_spatial_fold}()},
\code{\link{weights_from_distance_matrix}()}
}
\concept{preprocessing}
