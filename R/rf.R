#' @title Fits random forest models and tests the spatial correlation of the residuals
#' @description A convenient wrapper for \link[ranger]{ranger} that completes its output by providing the Moran's I of the residuals for different distance thresholds, the rmse and nrmse (as computed by [root_mean_squared_error()]), and variable importance scores based on a scaled version of the data generated by [scale_robust()].
#' @param data Data frame with a response variable and a set of predictors. Default: `NULL`
#' @param dependent.variable.name Character string with the name of the response variable. Must be in the column names of `data`. Default: `NULL`
#' @param predictor.variable.names Character vector with the names of the predictive variables. Every element of this vector must be in the column names of `data`. Optionally, the result of [auto_cor()] or [auto_vif()] Default: `NULL`
#' @param distance.matrix Squared matrix with the distances among the records in `data`. The number of rows of `distance.matrix` and `data` must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: `NULL`
#' @param distance.thresholds Numeric vector with neighborhood distances. All distances in the distance matrix below each value in `dustance.thresholds` are set to 0 for the computation of Moran's I. If `NULL`, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: `NULL`
#' @param ranger.arguments Named list with \link[ranger]{ranger} arguments (other arguments of this function can also go here). All \link[ranger]{ranger} arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. The ranger arguments `x`, `y`, and `formula` are disabled. Please, consult the help file of \link[ranger]{ranger} if you are not familiar with the arguments of this function.
#' @param scaled.importance Logical, if `TRUE`, the function scales `data` with [scale_robust()] and fits a new model to compute scaled variable importance scores. This makes variable importance scores of different models somewhat comparable. Default: `TRUE`
#' @param seed Integer, random seed to facilitate reproducibility. If set to a given number, the returned model is always the same. Default: `NULL`
#' @param verbose Boolean. If TRUE, messages and plots generated during the execution of the function are displayed. Default: `TRUE`
#' @return A ranger model with several new slots:
#' \itemize{
#'   \item `ranger.arguments`: Stores the values of the arguments used to fit the ranger model.
#'   \item `variable.importance`: A list containing a data frame with the predictors ordered by their importance, and a ggplot showing the importance values.
#'   \item `performance`: out-of-bag performance scores: R squared, pseudo R squared, RMSE, and normalized RMSE (NRMSE).
#'   \item `pseudo.r.squared`: computed as the correlation between the observations and the predictions.
#'   \item `residuals`: computed as observations minus predictions.
#'   \item `spatial.correlation.residuals`: the result of [moran_multithreshold()] applied to the model results.
#' }
#' @details Please read the help file of \link[ranger]{ranger} for further details. Notice that the `formula` interface of \link[ranger]{ranger} is supported through `ranger.arguments`, but variable interactions are not allowed (but check [rf_interactions()]).
#' @examples
#' \donttest{
#' if(interactive()){
#'
#'  data("plant_richness_df")
#'  data("distance_matrix")
#'
#'  out <- rf(
#'    data = plant_richness_df,
#'    dependent.variable.name = "richness_species_vascular",
#'    predictor.variable.names = colnames(plant_richness_df)[5:21],
#'    distance.matrix = distance_matrix,
#'    distance.thresholds = c(0, 100, 1000, 10000)
#'  )
#'
#'  class(out)
#'
#'  #data frame with ordered variable importance
#'  out$variable.importance$per.variable
#'
#'  #variable importance plot
#'  out$variable.importance$plot
#'
#'  #pseudo R-squared
#'  out$pseudo.r.squared
#'
#'  #rmse and nrmse
#'  out$rmse
#'  out$nrmse
#'
#'  #spatial correlation of the residuals for different distance thresholds
#'  out$spatial.correlation.residuals$df
#'
#'  #plot of the Moran's I of the residuals for different distance thresholds
#'  out$spatial.correlation.residuals$plot
#'
#'  #predictions for new data as done with ranger models:
#'  predicted <- stats::predict(
#'    object = out,
#'    data = plant_richness_df,
#'    type = "response"
#'  )$predictions
#'
#'  #alternative data input methods
#'  ###############################
#'
#'  #ranger.arguments can contain ranger arguments and any other rf argument
#'  my.arguments <- list()
#'  my.arguments$data <- plant_richness_df
#'  my.arguments$dependent.variable.name <- "richness_species_vascular"
#'  my.arguments$predictor.variable.names <- colnames(plant_richness_df)[8:21]
#'  my.arguments$distance.matrix <- distance_matrix
#'  my.arguments$distance.thresholds <- c(0, 100, 1000)
#'  out <- rf(ranger.arguments = my.arguments)
#'
#'  #the formula input method of ranger is supported (requires 'data')
#'  #variable interactions are not supported by this interface
#'  out <- rf(
#'    data = plant_richness_df,
#'    ranger.arguments = list(
#'      formula = as.formula(
#'      "richness_species_vascular ~
#'      climate_hypervolume +
#'      climate_velocity_lgm_average +
#'      neighbors_count +
#'      neighbors_percent_shared_edge"
#'      )
#'    )
#'  )
#'
#'  #the x and y interface is also supported (the name of the response variable is converted to "y")
#'  out <- rf(
#'    ranger.arguments = list(
#'      y = plant_richness_df$richness_species_vascular,
#'      x = plant_richness_df[, 5:21]
#'      )
#'    )
#'
#' }
#' }
#' @rdname rf
#' @export
#' @importFrom parallel detectCores
#' @importFrom tibble remove_rownames
#' @importFrom dplyr arrange
#' @importFrom stats formula reorder
#' @importFrom rlang .data
rf <- function(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  scaled.importance = TRUE,
  seed = NULL,
  verbose = TRUE
){

  #default ranger arguments
  num.trees = 500
  mtry = NULL
  mtry = NULL
  importance = "permutation"
  write.forest = TRUE
  probability = FALSE
  min.node.size = NULL
  max.depth = NULL
  replace = TRUE
  sample.fraction = ifelse(replace, 1, 0.632)
  case.weights = NULL
  class.weights = NULL
  splitrule = NULL
  num.random.splits = 1
  alpha = 0.5
  minprop = 0.1
  split.select.weights = NULL
  always.split.variables = NULL
  respect.unordered.factors = NULL
  scale.permutation.importance = TRUE
  local.importance = FALSE
  regularization.factor = 1
  regularization.usedepth = FALSE
  keep.inbag = FALSE
  inbag = NULL
  holdout = FALSE
  quantreg = FALSE
  oob.error = TRUE
  num.threads = parallel::detectCores() - 1
  save.memory = FALSE
  classification = NULL

  #creating ranger arguments if it does not exist
  if(is.null(ranger.arguments)){
    ranger.arguments <- list()
  }

  #were are data, dependent.variable.name, and predictor.variable.names coming from?
  if(is.null(data)){
    if("data" %in% names(ranger.arguments)){
      data <- ranger.arguments$data
    } else {
      stop("Argument 'data' not found.")
    }
  } else {
    if(!is.null(ranger.arguments)){
      ranger.arguments$data <- NULL
    }
  }

  if(is.null(dependent.variable.name)){
    if("dependent.variable.name" %in% names(ranger.arguments)){
      dependent.variable.name <- ranger.arguments$dependent.variable.name
    } else {
      stop("Argument 'dependent.variable.name' not found.")
    }
  } else {
    if(!is.null(ranger.arguments)){
      ranger.arguments$dependent.variable.name <- NULL
    }
  }

  if(is.null(predictor.variable.names)){
    if("predictor.variable.names" %in% names(ranger.arguments)){
      predictor.variable.names <- ranger.arguments$predictor.variable.names
    } else {
      stop("Argument 'predictor.variable.names' not found.")
    }
  } else {
    if(!is.null(ranger.arguments)){
      ranger.arguments$predictor.variable.names <- NULL
    }
    #predictor.variable.names comes from auto_vif or auto_cor
    if(inherits(predictor.variable.names, "variable_selection")){
      predictor.variable.names <- predictor.variable.names$selected.variables
    }
  }

  #checking if dependent.variable.name and predictor.variable.names are in colnames(data) and are numeric
  if(!(dependent.variable.name %in% colnames(data))){
    stop(
      paste0(
        "The dependent.variable.name ",
        dependent.variable.name,
        " is not a column of 'data'."
        )
      )
  } else {
    if(!is.numeric(data[, dependent.variable.name])){
      stop(
        paste0(
          "The dependent.variable.name ",
          dependent.variable.name,
          " is not numeric."
        )
      )
    }
  }
  if(sum(predictor.variable.names %in% colnames(data)) < length(predictor.variable.names)){
    stop(
      paste0(
        "The predictor.variable.names ",
        predictor.variable.names[!(predictor.variable.names %in% colnames(data))],
        " are missing from 'data'"
        )
      )
  }
  if(sum(apply(X = data[, predictor.variable.names], MARGIN = 2, FUN = is.numeric)) < length(predictor.variable.names)){
    stop(
      paste0(
        "The predictor.variable.names ",
        predictor.variable.names[!apply(X = data[, predictor.variable.names], MARGIN = 2, FUN = is.numeric)],
        " are not numeric."
      )
    )
  }

  #putting ranger arguments in the environment
  if(!is.null(ranger.arguments)){
    list2env(ranger.arguments, envir=environment())
  }

  #setting up seed if available
  if(!is.null(seed)){
    set.seed(seed)
  }

  #subset data
  data <- data[, c(dependent.variable.name, predictor.variable.names)]

  #ranger model for r-squared and predictions
  m <- ranger::ranger(
    data = data,
    dependent.variable.name = dependent.variable.name,
    num.trees = num.trees,
    mtry = mtry,
    importance = importance,
    write.forest = write.forest,
    probability = probability,
    min.node.size = min.node.size,
    max.depth = max.depth,
    replace = replace,
    sample.fraction = sample.fraction,
    case.weights = case.weights,
    class.weights = class.weights,
    splitrule = splitrule,
    num.random.splits = num.random.splits,
    alpha = alpha,
    minprop = minprop,
    split.select.weights = split.select.weights,
    always.split.variables = always.split.variables,
    respect.unordered.factors = respect.unordered.factors,
    scale.permutation.importance = scale.permutation.importance,
    local.importance = local.importance,
    regularization.factor = regularization.factor,
    regularization.usedepth = regularization.usedepth,
    keep.inbag = keep.inbag,
    inbag = inbag,
    holdout = holdout,
    quantreg = quantreg,
    oob.error = oob.error,
    num.threads = num.threads,
    save.memory = save.memory,
    verbose = verbose,
    seed = seed,
    classification = classification
  )

  #if scaled.importance is TRUE
  if(scaled.importance == TRUE){

    #applying robust scaling to the data
    data.scaled <- scale_robust(
      x = data
    )

    #if scaling fails, use regular scaling
    if(sum(is.nan(data.scaled[, 1])) > 0 | sum(is.infinite(data.scaled[, 1])) > 0){
      data.scaled <- as.data.frame(scale(data))
    }

    #ranger model for variable importance
    m.scaled <- ranger::ranger(
      data = data.scaled,
      dependent.variable.name = dependent.variable.name,
      num.trees = num.trees,
      mtry = mtry,
      importance = importance,
      write.forest = write.forest,
      probability = probability,
      min.node.size = min.node.size,
      max.depth = max.depth,
      replace = replace,
      sample.fraction = sample.fraction,
      case.weights = case.weights,
      class.weights = class.weights,
      splitrule = splitrule,
      num.random.splits = num.random.splits,
      alpha = alpha,
      minprop = minprop,
      split.select.weights = split.select.weights,
      always.split.variables = always.split.variables,
      respect.unordered.factors = respect.unordered.factors,
      scale.permutation.importance = FALSE,
      local.importance = local.importance,
      regularization.factor = regularization.factor,
      regularization.usedepth = regularization.usedepth,
      keep.inbag = keep.inbag,
      inbag = inbag,
      holdout = holdout,
      quantreg = quantreg,
      oob.error = oob.error,
      num.threads = num.threads,
      save.memory = save.memory,
      verbose = verbose,
      seed = seed,
      classification = classification
    )

  } else {

    m.scaled <- m

  }

  #adding model arguments
  m$ranger.arguments <- list(
    data = data,
    dependent.variable.name = dependent.variable.name,
    predictor.variable.names = predictor.variable.names,
    distance.matrix = distance.matrix,
    distance.thresholds = distance.thresholds,
    num.trees = num.trees,
    mtry = mtry,
    importance = importance,
    scaled.importance = scaled.importance,
    write.forest = write.forest,
    probability = probability,
    min.node.size = min.node.size,
    max.depth = max.depth,
    replace = replace,
    sample.fraction = sample.fraction,
    case.weights = case.weights,
    class.weights = class.weights,
    splitrule = splitrule,
    num.random.splits = num.random.splits,
    alpha = alpha,
    minprop = minprop,
    split.select.weights = split.select.weights,
    always.split.variables = always.split.variables,
    respect.unordered.factors = respect.unordered.factors,
    scale.permutation.importance = scale.permutation.importance,
    local.importance = local.importance,
    regularization.factor = regularization.factor,
    regularization.usedepth = regularization.usedepth,
    keep.inbag = keep.inbag,
    inbag = inbag,
    holdout = holdout,
    quantreg = quantreg,
    oob.error = oob.error,
    num.threads = num.threads,
    save.memory = save.memory,
    seed = seed,
    classification = classification
  )

  #importance dataframe
  if(importance == "permutation"){
    m$variable.importance <- list()
    m$variable.importance$per.variable <- data.frame(
      variable = names(m.scaled$variable.importance),
      importance = m.scaled$variable.importance
    ) %>%
      tibble::remove_rownames() %>%
      dplyr::arrange(dplyr::desc(importance)) %>%
      dplyr::mutate(importance = round(importance, 3)) %>%
      as.data.frame()

    variable <- NULL
    m$variable.importance$plot <- plot_importance(
      x = m$variable.importance$per.variable,
      verbose = verbose
    )
  }

  #getting residuals

  #predicted data
  predicted <- m$predictions

  #getting observed data
  observed <- data[, dependent.variable.name]

  #performance slot
  m$performance <- list()
  m$performance$r.squared <- round(cor(observed, predicted) ^ 2, 3)
  m$performance$pseudo.r.squared <- round(cor(
    observed,
    predicted
  ), 3)
  m$performance$rmse <- round(root_mean_squared_error(
    o = observed,
    p = predicted,
    normalization = NULL
  ), 3)
  names(m$performance$rmse) <- NULL
  m$performance$nrmse <- round(root_mean_squared_error(
    o = observed,
    p = predicted,
    normalization = "iq"
  ), 3)
  names(m$performance$nrmse) <- NULL

  #residuals
  m$residuals <- observed - predicted


  #compute moran I of residuals if distance.matrix is provided
  if(!is.null(distance.matrix)){

    m$spatial.correlation.residuals <- moran_multithreshold(
      x = m$residuals,
      distance.matrix = distance.matrix,
      distance.thresholds = distance.thresholds,
      verbose = verbose
    )

  }

  #replacing local variable importance with the scaled one
  if(local.importance == TRUE){
    m$variable.importance.local <- m.scaled$variable.importance.local
  }

  #adding rf class
  class(m) <- c("rf", "ranger")

  if(verbose == TRUE){
    print(m)
  }

  #return model
  m

}
