% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rank_spatial_predictors.R
\name{rank_spatial_predictors}
\alias{rank_spatial_predictors}
\title{rank_spatial_predictors}
\usage{
rank_spatial_predictors(
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  ranger.arguments = NULL,
  spatial.predictors.df = NULL,
  ranking.method = c("moran.i.reduction", "mem"),
  reference.moran.i = 1,
  multicollinearity.filter = c("vif", "cor", "none"),
  n.cores = NULL,
  cluster.ips = NULL,
  cluster.cores = NULL,
  cluster.user = NULL,
  cluster.port = 11000
)
}
\arguments{
\item{data}{(required) data frame with a response variable and a set of (preferably uncorrelated) predictors, Default: NULL}

\item{dependent.variable.name}{(required) string with the name of the response variable. Must be in the column names of 'data', Default: NULL}

\item{predictor.variable.names}{(required) character vector with the names of the predictive variables. Every element must be in the column names of 'data', Default: NULL}

\item{distance.matrix}{(optional) a squared matrix with the distances among the records in 'data'. Notice that the rows of 'distance.matrix' and 'data' must be the same. If not provided, the computation of the Moran's I of the residuals is ommited. Default: NULL.}

\item{distance.thresholds}{(optional) numeric vector, distances below each value in the distance matrix are set to 0 for the computation of Moran's I. If NULL, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: NULL.}

\item{ranger.arguments}{(optional) list with \link[ranger]{ranger} arguments. See \link{rf} or \link{rf_repeat} for further details.}

\item{spatial.predictors.df}{data frame of spatial predictors, either a distance matrix, or the PCA factors of the distance matrix produced by \link{pca_distance_matrix}.}

\item{ranking.method}{string, one of "moran.i.reduction" and "mem". The former option ranks spatial predictors according how much each predictor reduces Moran's I of the model residuals.}

\item{reference.moran.i}{Moran's I of the residuals of a model fitted without spatial predictors. Default: 1.}

\item{multicollinearity.filter}{method to reduce multicollinearity in the ranked spatial predictors, one of "vif" (triggers \link{auto_vif}), "cor" (triggers \link{auto_cor}), and "none" (does not apply a multicollinearity filter).}

\item{n.cores}{number of cores to use to compute repetitions. If NULL, all cores but one are used, unless a cluster is used.}

\item{cluster.ips}{character vector, IPs of the machines in the cluster. The first machine will be considered the main node of the cluster, and will generally be the machine on which the R code is being executed.}

\item{cluster.cores}{numeric integer vector, number of cores on each machine.}

\item{cluster.user}{character string, name of the user (should be the same throughout machines), Defaults to the current system user. Default: user name of the current session.}

\item{cluster.port}{integer, port used by the machines in the cluster to communicate. The firewall in all computers must allow traffic from and to such port. Default: 11000.}
}
\value{
a list with two slots:
\itemize{
\item{ranking.criteria}{data frame with two different configurations depending on the ranking method. If ranking.method = "moran.i.reduction", the columns contain the name of the spatial predictor, the r-squared of the model, the Moran's I of the model residuals, the difference between this Moran's I and the Moran's I of the model fitted without spatial predictors (named \code{ranking.criteria}, and the interpretation of the Moran's I value. If ranking.method = "mem", only the name of the spatial predictor, it's Moran's I and the interpretation are available.}
\item{ranking}{ordered character vector with the names of the spatial predictors selected after the multicollinearity filtering (if applied)}
}
}
\description{
ranks spatial predictors generated from the PCA of a distance matrix (or columns of the distance matrix itself) by either their effect in reducing the Moran's I of the model residuals (ranking.method = "moran.i.reduction"), or by their own Moran's I (ranking.method = "mem"). In the former case, one model of the type \code{y ~ predictors + spatial_predictor_X} is fitted per spatial predictor (this is a computationally intensive function), and the Moran's I of its residuals is compared with the one of the model \code{y ~ predictors}, to finally order the spatial predictor from maximum to minimum Moran's I difference. In the latter case the spatial predictors are ordered by their Moran's I alone (this is the faster option). In both cases, the ranked spatial predictors undergo a multicollinearity filtering through \link{auto_cor} or \link{auto_vif}, in order to reduce as much as possible the total number of spatial predictors to reduce computation time downstream. The purpose of this function is to provide criteria on how to include spatial predictors in a model. This function has been designed to be used internally by rf_spatial rather than by directly by a user.
}
\examples{
\dontrun{
if(interactive()){
 data("distance_matrix")

 spatial.predictors.df <- pca_distance_matrix(
   x = distance_matrix[1:50, 1:50],
   distance.thresholds = c(0, 100, 1000)
 )

 #ranking by the Moran's I of the spatial predictor
 rank <- rank_spatial_predictors(
   distance.matrix = distance_matrix[1:50, 1:50],
   distance.thresholds = c(0, 100, 1000),
   spatial.predictors.df = spatial.predictors.df,
   ranking.method = "mem",
   n.cores = 1,
   multicollinearity.filter = "vif"
 )
 rank$ranking.criteria
 rank$ranking
 }
}
}
