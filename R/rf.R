#' @title Random forest models with Moran's I test of the residuals
#' @description A convenient wrapper for \link[ranger]{ranger} that completes its output by providing the Moran's I of the residuals for different distance thresholds, the rmse and nrmse (as computed by [root_mean_squared_error()]), and variable importance scores based on a scaled version of the data generated by \link[base]{scale}.
#' @param model (required if `data` is `NULL`; model produced with `spatialRF`) A model fitted with [rf()]. If provided, it overrides all other input arguments (these are: `data`, `dependent.variable.name`, `predictor.variable.names`, `distance.matrix`, `distance.thresholds`, `xy`). However, you can provide new execution arguments and hyperparameters (like: `num.trees`, `mtry`, and any other argument accepted by the function `ranger::ranger()`) via the argument `ranger.arguments`. Default: `NULL`.
#' @param data (required if `model` is `NULL`; data frame or tibble) Data frame with a response variable and a set of predictors. If `data` is a tibble, all data frames in the output model are coerced to tibble. Default: `NULL`
#' @param dependent.variable.name (required if `model` is `NULL`; character string) Character string with the name of the response variable. Must be in the column names of `data`. If the dependent variable is binary with values 1 and 0, the argument `case.weights` of `ranger` is populated by the function [case_weights()]. Default: `NULL`
#' @param predictor.variable.names (required if `model` is `NULL`; character vector with column names of `data`) Character vector with the names of the predictive variables. Every element of this vector must be in the column names of `data`. Optionally, the result of [auto_cor()] or [auto_vif()]. Default: `NULL`
#' @param distance.matrix (optional; distance matrix) Squared matrix with the distances among the records in `data`. The number of rows of `distance.matrix` and `data` must be the same. If not provided, the computation of the Moran's I of the residuals is omitted. Default: `NULL`
#' @param distance.thresholds  (optional; numeric vector with distances in the same units as `distance.matrix`) Numeric vector with neighborhood distances. All distances in the distance matrix below each value in `dustance.thresholds` are set to 0 for the computation of Moran's I. If `NULL`, it defaults to seq(0, max(distance.matrix), length.out = 4). Default: `NULL`
#' @param xy (optional; data frame, tibble, or matrix) Data frame or matrix with two columns containing coordinates and named "x" and "y". It is not used by this function, but it is stored in the slot `ranger.arguments$xy` of the model, so it can be used by [rf_evaluate()] and [rf_tuning()]. Default: `NULL`
#' @param ranger.arguments (optional; list with ranger::ranger() arguments) Named list with \link[ranger]{ranger} arguments. All \link[ranger]{ranger} arguments are set to their default values except for 'importance', that is set to 'permutation' rather than 'none'. The ranger arguments `x`, `y`, and `formula` are disabled. Please, consult the help file of \link[ranger]{ranger} if you are not familiar with the arguments of this function. Default: `NULL`.
#' @param scaled.importance (optional; logical) If `TRUE`, the function scales `data` with \link[base]{scale} and fits a new model to compute scaled variable importance scores. Relevant to compare importance scores across models with different response variables. Default: `FALSE`
#' @param seed (optional; integer) Random seed to facilitate reproducibility. If set to a given number, the returned model is always the same. Default: `1`
#' @param verbose (optional; logical) If TRUE, messages and plots generated during the execution of the function are displayed. Default: `TRUE`
#' @param n.cores (optional; integer) Number of cores to use. Default: `parallel::detectCores() - 1`
#' @param cluster (optional; cluster object) A cluster definition generated with `parallel::makeCluster()` or \code{\link{start_cluster}}. Only advisable if you need to spread a large number of repetitions over the nodes of a large cluster when working with large data. If provided, overrides `n.cores`. The function does not stop a cluster, please remember to shut it down with `parallel::stopCluster(cl = cluster_name)` or `spatialRF::stop_cluster()` at the end of your pipeline. Default: `NULL`
#' @return A ranger model with several extra slots:
#' \itemize{
#'   \item `ranger.arguments`: Stores the values of the arguments used to fit the ranger model.
#'   \item `predictions`: Predicted values.
#'   \itemize{
#'    \item `full`: Numeric vector, predictions computed on the from the full training dataset.
#'    \item `oob`: Numeric vector, predictions computed on the out-of-bag data.
#'   }
#'   \item `importance`: A list containing a data frame with the predictors ordered by their importance, a ggplot showing the importance values, and local importance scores (difference in accuracy between permuted and non permuted variables for every case, computed on the out-of-bag data).
#'   \item `performance`: Performance scores computed on the full training data ("full") and out-of-bag data ("oob").
#'   \itemize{
#'     \item `rsquared_full`: R-squared computed on the predictions of the full training dataset using the expression `cor(observed, predicted_oob) ^ 2`.
#'     \item `rsquared_oob`: As above, but using the out-of-bag predictions instead.
#'     \item `rmse_full`: Root mean squared error computed on the predictions of the full training dataset using the expression `spatialRF::root_mean_squared_error(o = observed, p = predicted)`
#'     \item `rmse_oob`: As above, but using the out-of-bag predictions instead.
#'     \item `nrmse_full`: Interquartile-normalized root mean squared error computed on the predictions of the full training dataset using the expression `spatialRF::root_mean_squared_error(o = observed, p = predicted_oob, normalization = "iq")`.
#'     \item `nrmse_oob`: As above, but using the out-of-bag predictions instead.
#'     \item `auc_full`: (only for binomial responses) Area under the ROC curve computed using the predictions of the full training dataset using the expression `spatialRF::auc(o = observed, p = predicted_oob)`.
#'     \item `auc_oob`: Only for binary responses with values 0 and 1. Area under the ROC curve computed on the out-of-bag predictions using the expression .
#'     \item `rsquared_full`: R-squared computed on the in-bag predictions using the expression `cor(observed, predicted_full) ^ 2`.
#'     \item `rmse_full`: Root mean squared error computed on the in-bag predictions using the expression `spatialRF::root_mean_squared_error(o = observed, p = predicted_full)`.
#'     \item `nrmse_full`: Normalized rood mean squared error computed on the in-bag data using the expression `spatialRF::root_mean_squared_error(o = observed, p = predicted_full, normalization = "iq")`.
#'     \item `auc_full`: Only for binary responses with values 0 and 1. Area under the ROC curve computed on the in-bag predictions using the expression `spatialRF::auc(o = observed, p = predicted_full)`.
#'   }
#'   \item `residuals`: residuals, normality test of the residuals computed with [residuals_test()], and spatial autocorrelation of the residuals computed with [moran_multithreshold()].
#' }
#' @details Please read the help file of \link[ranger]{ranger} for further details. Notice that the `formula` interface of \link[ranger]{ranger} is supported through `ranger.arguments`, but variable interactions are not allowed (but check [the_feature_engineer()]).
#' @examples
#' if(interactive()){
#'
#'  #loading example data
#'  data(
#'   ecoregions_df,
#'   ecoregions_distance_matrix,
#'   ecoregions_predictor_variable_names,
#'   ecoregions_dependent_variable_name
#'   )
#'
#'  #fitting random forest model
#'  out <- rf(
#'    data = ecoregions_df,
#'    dependent.variable.name = ecoregions_dependent_variable_name,
#'    predictor.variable.names = ecoregions_predictor_variable_names,
#'    distance.matrix = ecoregions_distance_matrix,
#'    distance.thresholds = 0,
#'    n.cores = 1
#'  )
#'
#'  class(out)
#'
#'  #data frame with ordered variable importance
#'  out$importance$global
#'
#'  #variable importance plot
#'  out$importance_per_variable_plot
#'
#'  #performance
#'  out$performance
#'
#'  #spatial correlation of the residuals
#'  out$spatial_correlation_residuals$per_distance
#'
#'  #plot of the Moran's I of the residuals for different distance thresholds
#'  out$spatial.correlation.residuals$plot
#'
#'  #predictions for new data as done with ranger models:
#'  predicted <- stats::predict(
#'    object = out,
#'    data = ecoregions_df,
#'    type = "response"
#'  )$predictions
#'
#'
#'  #re-fitting a model with different hyperparameters
#'  ###################################################
#'  out.custom <- rf(
#'    model = out,
#'    ranger.arguments = list(
#'      num.trees = 5000,
#'      mtry = 3,
#'      min.node.size = 10
#'    )
#'  )
#'
#'  #alternative data input methods
#'  ###############################
#'
#'  #ranger.arguments
#'  my.ranger.arguments <- list(
#'  data = ecoregions_df,
#'  dependent.variable.name = ecoregions_dependent_variable_name,
#'  predictor.variable.names = ecoregions_predictor_variable_names,
#'  distance.matrix = ecoregions_distance_matrix,
#'  distance.thresholds = c(0, 1000)
#'  )
#'
#'  #fitting model with these ranger arguments
#'  out <- rf(
#'    ranger.arguments = my.ranger.arguments,
#'    n.cores = 1
#'    )
#'
#' }
#' @rdname rf
#' @export
#' @importFrom parallel detectCores
#' @importFrom tibble remove_rownames
#' @importFrom dplyr arrange
#' @importFrom stats formula reorder median cor.test
#' @importFrom rlang .data
rf <- function(
  model = NULL,
  data = NULL,
  dependent.variable.name = NULL,
  predictor.variable.names = NULL,
  distance.matrix = NULL,
  distance.thresholds = NULL,
  xy = NULL,
  ranger.arguments = NULL,
  scaled.importance = FALSE,
  seed = 1,
  verbose = TRUE,
  n.cores = parallel::detectCores() - 1,
  cluster = NULL
){

  #DEFAULT RANGER ARGUMENTS
  ###########################################

  #declaring variables to avoid check notes
  num.trees <- NULL
  mtry <- NULL
  importance <- NULL
  write.forest <- NULL
  probability <- NULL
  min.node.size <- NULL
  max.depth <- NULL
  replace <- NULL
  sample.fraction <- NULL
  case.weights <- NULL
  class.weights <- NULL
  splitrule <- NULL
  num.random.splits <- NULL
  alpha <- NULL
  minprop <- NULL
  split.select.weights <- NULL
  always.split.variables <- NULL
  respect.unordered.factors <- NULL
  scale.permutation.importance <- NULL
  local.importance <- NULL
  regularization.factor <- NULL
  regularization.usedepth <- NULL
  keep.inbag <- NULL
  inbag <- NULL
  holdout <- NULL
  quantreg <- NULL
  oob.error <- NULL
  num.threads <- NULL
  save.memory <- NULL
  classification <- NULL

  #default ranger arguments
  ranger.arguments.default <- list(
    num.trees = 500,
    mtry = NULL,
    importance = "permutation",
    write.forest = TRUE,
    probability = FALSE,
    min.node.size = NULL,
    max.depth = NULL,
    replace = TRUE,
    sample.fraction =1,
    case.weights = NULL,
    class.weights = NULL,
    splitrule = NULL,
    num.random.splits = 1,
    alpha = 0.5,
    minprop = 0.1,
    split.select.weights = NULL,
    always.split.variables = NULL,
    respect.unordered.factors = NULL,
    scale.permutation.importance = TRUE,
    local.importance = TRUE,
    regularization.factor = 1,
    regularization.usedepth = FALSE,
    keep.inbag = FALSE,
    inbag = NULL,
    holdout = FALSE,
    quantreg = FALSE,
    oob.error = TRUE,
    num.threads = n.cores,
    save.memory = FALSE,
    classification = NULL
  )

  #writing the default ranger.arguments to the function environment
  list2env(ranger.arguments.default, envir=environment())

  #HANDLING ARGUMENTS
  ######################################

  #if model is provided
  if(!is.null(model)){

    #stopping if model is not of the right class
    if(!("rf" %in% class(model))){
      stop("The argument 'model' is not of the class 'rf'.")
    }

    #RULE 1: if ranger.arguments is not provided
    if(is.null(ranger.arguments)){

      #overriding input arguments
      data <- NULL
      dependent.variable.name <- NULL
      predictor.variable.names <- NULL

      #letting the user add elements if they are missing
      if(is.null(model$ranger_arguments$distance.matrix) & !is.null(distance.matrix)){
        model$ranger_arguments$distance.matrix <- distance.matrix
      }

      if(is.null(model$ranger_arguments$distance.thresholds) & !is.null(distance.thresholds)){
        model$ranger_arguments$distance.thresholds <- distance.thresholds
      }

      if(!is.null(xy) & !is.null(ranger.arguments$xy)){
      if(is.null(model$ranger_arguments$xy) & !is.null(xy)){
        model$ranger_arguments$xy <- xy
      }
      }

      if(!is.null(scaled.importance) & !is.null(ranger.arguments$scaled.importance)){
      if(model$ranger_arguments$scaled.importance != scaled.importance){
        model$ranger_arguments$scaled.importance <- scaled.importance
      }
      }

      if(!is.null(seed) & !is.null(ranger.arguments$seed)){
      if(model$ranger_arguments$seed != seed){
        model$ranger_arguments$seed <- seed
      }
      }

      if(!is.null(n.cores) & !is.null(ranger.arguments$n.cores)){
      if(model$ranger_arguments$n.cores != n.cores){
        model$ranger_arguments$n.cores <- n.cores
      }
      }

      #writing the model's ranger.arguments to the environment
      ranger.arguments <- model$ranger_arguments

      #writing arguments to the function environment
      list2env(model$ranger_arguments, envir=environment())

    } else {

      #RULE 2:
      #input arguments in model$ranger_arguments take precedence

      #letting the user add elements if they are missing
      if(!is.null(distance.matrix) & !is.null(ranger.arguments$distance.matrix)){
      if(is.null(ranger.arguments$distance.matrix) & !is.null(distance.matrix)){
        ranger.arguments$distance.matrix <- distance.matrix
      }
      }

      if(!is.null(distance.thresholds) & !is.null(ranger.arguments$distance.thresholds)){
      if(is.null(ranger.arguments$distance.thresholds) & !is.null(distance.thresholds)){
        ranger.arguments$distance.thresholds <- distance.thresholds
      }
      }

      if(!is.null(xy) & !is.null(ranger.arguments$xy)){
      if(is.null(ranger.arguments$xy) & !is.null(xy)){
        ranger.arguments$xy <- xy
      }
      }

      if(!is.null(scaled.importance) & !is.null(ranger.arguments$scaled.importance)){
      if(ranger.arguments$scaled.importance != scaled.importance){
        ranger.arguments$scaled.importance <- scaled.importance
      }
      }

      if(!is.null(seed) & !is.null(ranger.arguments$seed)){
      if(ranger.arguments$seed != seed){
        ranger.arguments$seed <- seed
      }
      }

      if(!is.null(n.cores) & !is.null(ranger.arguments$n.cores)){
        if(ranger.arguments$n.cores != n.cores){
          ranger.arguments$n.cores <- n.cores
        }
      }


      #writing arguments to the function environment
      list2env(model$ranger_arguments, envir=environment())
      list2env(ranger.arguments, envir=environment())


    }

  } else {
    #RULE 3:

    if(!is.null(ranger.arguments)){

      if(is.null(data)){
        data <- model$ranger_arguments$data
      }

      if(is.null(dependent.variable.name)){
        dependent.variable.name <- model$ranger_arguments$dependent.variable.name
      }

      if(is.null(predictor.variable.names)){
        predictor.variable.names <- model$ranger_arguments$predictor.variable.names
      }

      if(is.null(distance.matrix)){
        distance.matrix <- model$ranger_arguments$distance.matrix
      }

      if(is.null(distance.thresholds)){
        distance.thresholds <- model$ranger_arguments$distance.thresholds
      }

      if(is.null(xy)){
        xy <- model$ranger_arguments$xy
      }

      if(is.null(cluster)){
        cluster <- model$ranger_arguments$cluster
      }

      if(is.null(seed)){
        seed <- model$ranger_arguments$seed
      }

      if(is.null(n.cores)){
        n.cores <- model$ranger_arguments$n.cores
      }

      #writing ranger.arguments to the function environment
      list2env(ranger.arguments, envir=environment())

    }

  }

  #predictor.variable.names comes from auto_vif or auto_cor
  if(inherits(predictor.variable.names, "variable_selection")){

    predictor.variable.names <- predictor.variable.names$selected.variables

  }

  #END OF HANDLING ARGUMENTS
  ##########################

  #predictor.variable.names comes from auto_vif or auto_cor
  if(inherits(predictor.variable.names, "variable_selection")){

    predictor.variable.names <- predictor.variable.names$selected.variables

  } else {

    if(sum(predictor.variable.names %in% colnames(data)) < length(predictor.variable.names)){

      stop(
        paste0(
          "The predictor.variable.names ",
          paste0(
            predictor.variable.names[!(predictor.variable.names %in% colnames(data))],
            collapse = ", "
          ),
          " are missing from 'data'"
        )
      )
    }
  }

  #checking if dependent.variable.name and predictor.variable.names are in colnames(data)
  if(!(dependent.variable.name %in% colnames(data))){
    stop(
      paste0(
        "The dependent.variable.name ",
        dependent.variable.name,
        " is not a column of 'data'."
      )
    )
  }

  #subset data
  data <- data[, c(dependent.variable.name, predictor.variable.names)]

  #check if input is tibble
  if(tibble::is_tibble(data) == TRUE){
    return.tibble <- TRUE
  } else {
    return.tibble <- FALSE
  }

  #setting up seed if available
  if(!is.null(seed)){
    set.seed(seed)
  }

  #scaling the data if required
  if(scaled.importance == TRUE){

    data.scaled <-  as.data.frame(scale(x = data))

    #check if there are NaN
    if(sum(apply(data.scaled, 2, is.nan)) > 0 | sum(apply(data.scaled, 2, is.infinite)) > 0){
      scaled.importance <- FALSE
      warning("The training data yields NaN or Inf when scaled, setting scaled.importance to FALSE.")
    }

  }

  #computing case weights if dependent.variable.name is binary
  case.weights <- case_weights(
    x = dplyr::pull(
      data,
      dependent.variable.name
      ),
    case.weights = case.weights
  )

  #ranger model for r-squared and predictions
  m <- ranger::ranger(
    data = data,
    dependent.variable.name = dependent.variable.name,
    num.trees = num.trees,
    mtry = mtry,
    importance = importance,
    write.forest = write.forest,
    probability = probability,
    min.node.size = min.node.size,
    max.depth = max.depth,
    replace = replace,
    sample.fraction = sample.fraction,
    case.weights = case.weights,
    class.weights = class.weights,
    splitrule = splitrule,
    num.random.splits = num.random.splits,
    alpha = alpha,
    minprop = minprop,
    split.select.weights = split.select.weights,
    always.split.variables = always.split.variables,
    respect.unordered.factors = respect.unordered.factors,
    scale.permutation.importance = scale.permutation.importance,
    local.importance = local.importance,
    regularization.factor = regularization.factor,
    regularization.usedepth = regularization.usedepth,
    keep.inbag = keep.inbag,
    inbag = inbag,
    holdout = holdout,
    quantreg = quantreg,
    oob.error = oob.error,
    num.threads = num.threads,
    save.memory = save.memory,
    verbose = verbose,
    seed = seed,
    classification = classification
  )

  #get variable importance
  variable.importance.global <- m$variable.importance
  variable.importance.local <- m$variable_importance_local

  #if scaled.importance is TRUE
  if(scaled.importance == TRUE){

    #ranger model for variable importance
    m.scaled <- ranger::ranger(
      data = data.scaled,
      dependent.variable.name = dependent.variable.name,
      num.trees = num.trees,
      mtry = mtry,
      importance = importance,
      write.forest = write.forest,
      probability = probability,
      min.node.size = min.node.size,
      max.depth = max.depth,
      replace = replace,
      sample.fraction = sample.fraction,
      case.weights = case.weights,
      class.weights = class.weights,
      splitrule = splitrule,
      num.random.splits = num.random.splits,
      alpha = alpha,
      minprop = minprop,
      split.select.weights = split.select.weights,
      always.split.variables = always.split.variables,
      respect.unordered.factors = respect.unordered.factors,
      scale.permutation.importance = FALSE,
      local.importance = local.importance,
      regularization.factor = regularization.factor,
      regularization.usedepth = regularization.usedepth,
      keep.inbag = keep.inbag,
      inbag = inbag,
      holdout = holdout,
      quantreg = quantreg,
      oob.error = oob.error,
      num.threads = num.threads,
      save.memory = save.memory,
      verbose = verbose,
      seed = seed,
      classification = classification
    )

    #overwrite variable importance
    variable.importance.global <- m.scaled$variable.importance
    variable.importance.local <- m.scaled$variable_importance_local

  }

  #adding model arguments
  m$ranger_arguments <- list(
    data = data,
    dependent.variable.name = dependent.variable.name,
    predictor.variable.names = predictor.variable.names,
    distance.matrix = distance.matrix,
    distance.thresholds = distance.thresholds,
    xy = xy,
    num.trees = num.trees,
    mtry = mtry,
    importance = importance,
    scaled.importance = scaled.importance,
    write.forest = write.forest,
    probability = probability,
    min.node.size = min.node.size,
    max.depth = max.depth,
    replace = replace,
    sample.fraction = sample.fraction,
    case.weights = case.weights,
    class.weights = class.weights,
    splitrule = splitrule,
    num.random.splits = num.random.splits,
    alpha = alpha,
    minprop = minprop,
    split.select.weights = split.select.weights,
    always.split.variables = always.split.variables,
    respect.unordered.factors = respect.unordered.factors,
    scale.permutation.importance = scale.permutation.importance,
    local.importance = local.importance,
    regularization.factor = regularization.factor,
    regularization.usedepth = regularization.usedepth,
    keep.inbag = keep.inbag,
    inbag = inbag,
    holdout = holdout,
    quantreg = quantreg,
    oob.error = oob.error,
    num.threads = num.threads,
    save.memory = save.memory,
    seed = seed,
    classification = classification,
    cluster = cluster
  )

  #importance slot
  if(importance == "permutation"){

    #importance slot
    m$importance <- list()

    #global importance
    #sign of the importance
    variable.importance.global.sign <- variable.importance.global
    variable.importance.global.sign[variable.importance.global.sign >= 0] <- 1
    variable.importance.global.sign[variable.importance.global.sign < 0 ] <- -1

    #applying sqrt
    variable.importance.global <- sqrt(abs(variable.importance.global)) * variable.importance.global.sign

    m$importance$global <- data.frame(
      variable = names(variable.importance.global),
      importance = variable.importance.global
    ) %>%
      tibble::remove_rownames() %>%
      dplyr::arrange(dplyr::desc(importance)) %>%
      dplyr::mutate(importance = round(importance, 3))


    # m$importance$plot <- plot_importance(
    #   model = m$importance$global,
    #   verbose = verbose
    # )

    #local importance (reconverting values from ^2 to sqrt())

    #matrix with sign of the value
    variable.importance.local.sign <- variable.importance.local

    if(!is.null(variable.importance.local)){
      variable.importance.local.sign[variable.importance.local.sign >= 0] <- 1
      variable.importance.local.sign[variable.importance.local.sign < 0 ] <- -1

      #saving to the slot
      m$importance$local <- sqrt(abs(variable.importance.local)) * variable.importance.local.sign
    } else {
      m$importance$local <- NULL
    }


  }

  #getting oob predictions
  predicted_oob <- m$predictions

  #computing predictions
  predicted_full <- stats::predict(
    object = m,
    data = data,
    type = "response"
  )$predictions

  #saving predictions
  m$predictions <- list()
  m$predictions$full <- predicted_full
  m$predictions$oob <- predicted_oob

  #getting observed data
  observed <- dplyr::pull(data, dependent.variable.name)

  #MODEL PERFORMANCE
  ##################################

  #performance slot
  m$performance <- list()

  #defining_metrics
  if(is_binary_response(
    x = dplyr::pull(
      data,
      dependent.variable.name
      )
  ) == TRUE){

    #point biserial correlation
    m$performance$biserial_rsquared_oob <- stats::cor.test(
      x = observed,
      y = predicted_oob
    )$estimate

    m$performance$biserial_rsquared_full <- stats::cor.test(
      x = observed,
      y = predicted_full
    )$estimate

    #binary response metrics
    m$performance$auc_oob <- auc(
      o = observed,
      p = predicted_oob
    )

    m$performance$auc_full <- auc(
      o = observed,
      p = predicted_full
    )

    m$performance$roc_oob <- roc_curve(
      o = observed,
      p = predicted_oob
    )

    m$performance$roc_full <- roc_curve(
      o = observed,
      p = predicted_full
    )

    m$performance$sensitivity_0.5_full <- median(m$performance$roc_full$sensitivity_0.5)

    m$performance$sensitivity_0.5_oob <- median(m$performance$roc_oob$sensitivity_0.5)

    m$performance$specificity_0.5_full <- median(m$performance$roc_full$specificity_0.5)

    m$performance$specificity_0.5_oob <- median(m$performance$roc_oob$specificity_0.5)

  } else {

    #continuous response metrics
    m$performance$rsquared_oob <- cor(observed, predicted_oob) ^ 2
    m$performance$rsquared_full <- cor(observed, predicted_full) ^ 2

    m$performance$rmse_oob <- root_mean_squared_error(
      o = observed,
      p = predicted_oob,
      normalization = "rmse"
    )
    names(m$performance$rmse_oob) <- NULL

    m$performance$rmse_full <- root_mean_squared_error(
      o = observed,
      p = predicted_full,
      normalization = "rmse"
    )
    names(m$performance$rmse_full) <- NULL

    m$performance$nrmse_oob <- root_mean_squared_error(
      o = observed,
      p = predicted_oob,
      normalization = "iq"
    )
    names(m$performance$nrmse_oob) <- NULL

    m$performance$nrmse_full <- root_mean_squared_error(
      o = observed,
      p = predicted_full,
      normalization = "iq"
    )
    names(m$performance$nrmse_full) <- NULL


  }

  #remove NA
  m$performance[!is.na(m$performance)]

  #ordering performance list by name
  m$performance = m$performance[order(names(m$performance))]


  #residuals
  ############################
  m$residuals$values <- observed - predicted_full
  m$residuals$stats <- summary(m$residuals$values)

  #compute moran I of residuals if distance.matrix is provided
  if(!is.null(distance.matrix)){

    m$residuals$autocorrelation <- moran_multithreshold(
      x = m$residuals$values,
      distance.matrix = distance.matrix,
      distance.thresholds = distance.thresholds,
      verbose = verbose
    )

  }

  #normality of the residuals
  m$residuals$normality <- residuals_diagnostics(
    residuals = m$residuals$values,
    predictions = predicted_full
    )

  #plot of the residuals diagnostics
  # m$residuals$diagnostics <- plot_residuals_diagnostics(
  #   model = m,
  #   verbose = verbose
  # )

  #adding evaluation and tuning slots if they exist
  if(!is.null(model)){

    #saving tuning and evaluation slots for later
    if("tuning" %in% names(model)){
      m$tuning <- model$tuning
    }
    if("evaluation" %in% names(model)){
      m$evaluation <- model$evaluation
    }
    if("variable.selection" %in% names(model)){
      m$variable_selection <- model$variable_selection
    }
  }

  #adding cluster to model
  if(!is.null(cluster) & "cluster" %in% class(cluster)){
    m$ranger_arguments$cluster <- cluster
  }

  #adding rf class
  class(m) <- c("rf", "ranger")

  #coercing output to tibble
  if(return.tibble == TRUE){

    if(is.null(m$variable_importance_local) == FALSE){
      m$variable_importance_local <- tibble::as_tibble(m$variable_importance_local)
    }

    if(importance == "permutation"){
      m$importance$global <- tibble::as_tibble(m$importance$global)
      m$importance$local <- tibble::as_tibble(m$importance$local)
    }

    if(is.null(m$residuals$autocorrelation$per_distance) == FALSE){
      m$residuals$autocorrelation$per_distance <- tibble::as_tibble(m$residuals$autocorrelation$per_distance)

      if(!is.null(m$performance$roc_full)){
          m$performance$roc_full <- tibble::as_tibble(m$performance$roc_full)
          m$performance$roc_oob <- tibble::as_tibble(m$performance$roc_oob)
      }

    }

  }

  if(verbose == TRUE){
    print(m)
  }

  #return model
  m

}
